// ----------------------------------
// RSDK Project: Sonic 2
// Script Description: Player Object Object
// Script Author: Christian Whitehead/Simon Thomley
// Unpacked by Rubberduckycooly's script unpacker
// ----------------------------------

// ========================
// Aliases
// ========================
public alias  256 		: GROUP_PLAYERS
public alias  65536 	: HITBOX_AUTO
public alias  arrayPos6 : currentPlayer
public alias  arrayPos7 : playerCount

// Draw Order
private alias -1 : DRAWORDER_PLAYER

// Players
private alias 0 : PLAYER_SONIC_ALONE
private alias 1 : PLAYER_TAILS_ALONE
private alias 2 : PLAYER_KNUX_ALONE
private alias 3 : PLAYER_SONIC_AND_TAILS

// Shields
private alias 0 : SHIELD_NONE
private alias 1 : SHIELD_NORMAL
private alias 2 : SHIELD_BUBBLE
private alias 3 : SHIELD_FIRE
private alias 4 : SHIELD_LIGHTNING

// Super States
private alias 0 : SUPERSTATE_NONE
private alias 1 : SUPERSTATE_SUPER
private alias 2 : SUPERSTATE_FADEOUT
private alias 3 : SUPERSTATE_END

// Modes
private alias 2 : MODE_TIMEATTACK

// Tracks
private alias 0 : TRACK_STAGE
private alias 2 : TRACK_INVINCIBLE
private alias 5 : TRACK_GAMEOVER
private alias 7 : TRACK_SUPER

// Variables
private alias object.type			 :	player.type
private alias object.groupID		 :	player.groupID	 		// Normally GROUP_PLAYERS, unless in Debug Mode or some other strange scenario
private alias object.entityPos		 :	player.entityPos 		// Where the player is on the object list - P1 should be 0, P2 should be 1
private alias object.state			 :	player.state
private alias object.visible		 :	player.visible
private alias object.propertyValue	 :	player.character
private alias object.xpos			 :	player.xpos				// Total world-space position (0x10000 == 1.0)
private alias object.ypos			 :	player.ypos
private alias object.ixpos			 :	player.ixpos			// Screen space position (1 == 1)
private alias object.iypos			 :	player.iypos
private alias object.lookPosX		 :	player.lookPosX			// Camera offset based on this player's position
private alias object.lookPosY		 :	player.lookPosY
private alias object.xvel			 :	player.xvel				// Based on world-space (see above)
private alias object.yvel			 :	player.yvel
private alias object.speed			 :	player.speed			// Based on world-space (see above)
private alias object.rotation		 :	player.rotation			// Note: Because this is stored as a byte, it goes from 0-255, not 0-360!
private alias object.angle			 :	player.angle			// See above
private alias object.direction		 :	player.direction
private alias object.gravity		 :	player.gravity			// 1 if falling, 0 otherwise. Not to be confused with player.gravityStrength, see there for more info
private alias object.frame			 :	player.frame
private alias object.animation		 :	player.animation
private alias object.prevAnimation	 :	player.prevAnimation
private alias object.animationSpeed	 :	player.animationSpeed
private alias object.animationTimer	 :	player.animationTimer
private alias object.drawOrder		 :	player.drawOrder
private alias object.pushing		 :	player.pushing
private alias object.controlLock	 :	player.controlLock
private alias object.controlMode	 :	player.controlMode
private alias object.interaction	 :	player.interaction		// Will the object interact with tiles?
private alias object.scrollTracking	 :	player.scrollTracking	// Determines if the camera will track the player's position or just follow it
private alias object.collisionMode	 :	player.collisionMode
private alias object.collisionLeft	 :	player.collisionLeft
private alias object.collisionTop	 :	player.collisionTop
private alias object.collisionRight	 :	player.collisionRight
private alias object.collisionBottom :	player.collisionBottom
private alias object.collisionPlane	 :	player.collisionPlane
private alias object.floorSensorC	 :	player.floorSensorC
private alias object.floorSensorL	 :	player.floorSensorL
private alias object.floorSensorR	 :	player.floorSensorR
private alias object.tileCollisions	 :	player.tileCollisions
private alias object.priority		 :	player.priority

// *Object-wise* input, not to be confused with inputPress.X and inputDown.X
private alias object.jumpPress	:	player.jumpPress
private alias object.jumpHold	:	player.jumpHold
private alias object.up			:	player.up
private alias object.down		:	player.down
private alias object.left		:	player.left
private alias object.right		:	player.right

// Object value aliases
private alias object.value0  : player.rings
private alias object.value1  : player.timer
private alias object.value2  : player.abilityTimer			// Note: Also used by death/drowning state
private alias object.value3  : player.drownTimer			// Countdown before player moves to next drown "level"
private alias object.value4  : player.drownLevel
private alias object.value5  : player.customRollAnimSpeed
private alias object.value6  : player.speedShoesTimer
private alias object.value7  : player.invincibleTimer
private alias object.value8  : player.blinkTimer
private alias object.value9  : player.skidSpeed
private alias object.value10 : player.animationReserve		// Used by springs to store what animation will play after the bounce animation
private alias object.value11 : player.scrollDelay			// A timer of how long the camera will stay locked for

// Tails' tails' values
private alias object.value12 : player.tailFrame
private alias object.value13 : player.tailAnim

private alias object.value14 : player.skidding
// value15 isn't used
private alias object.value16 : player.isSidekick			// 0/false is player 1, 1/true if player 2
private alias object.value17 : debugMode.currentSelection
private alias object.value18 : player.sortedDrawOrder
private alias object.value19 : player.scoreBonus	// How many enemies the player has bounced on in a row
private alias object.value20 : player.topSpeed 			
private alias object.value21 : player.acceleration
private alias object.value22 : player.deceleration
private alias object.value23 : player.airAcceleration
private alias object.value24 : player.airDeceleration
private alias object.value25 : player.gravityStrength 		// Also used in underwater checks, 0x1000 if underwater, otherwise 0x3800. Not to be confused with player.gravity
private alias object.value26 : player.flightVelocity		// Used by Tails only
private alias object.value27 : player.jumpStrength
private alias object.value28 : player.jumpCap
private alias object.value29 : player.rollingFriction		// Active rolling deceleration - With the player holding the opposite direction
private alias object.value30 : player.jumpOffset			// Added to the player's position when jumping/rolling. Normally -5 for S&K, and -1 for Tails
private alias object.value31 : player.rollingDeceleration	// Passive rolling deceleration - Without the player holding the opposite direction
private alias object.value32 : player.jumpAbility			// Used to store whatever function this player has for its jump ability
private alias object.value33 : player.spindashFunction		// Used to store whatever function this player has for its spindash ability
private alias object.value34 : player.collisionDisabled
private alias object.value35 : player.jumpAbilityState
private alias object.value36 : player.flyCarryTimer			// Tails assist lockout timer
private alias object.value37 : player.shield				// Current shield the player has, see SHIELD_* constants
private alias object.value40 : player.hitboxLeft
private alias object.value38 : player.hitboxTop
private alias object.value41 : player.hitboxRight
private alias object.value39 : player.hitboxBottom
private alias object.value42 : player.prevGravity
// P2 values
private alias object.value43 : player.jumpInTimer
private alias object.value44 : player.p2InputFunction
private alias object.value45 : player.autoJumpTimer
private alias object.value46 : player.targetLeaderPos.x
private alias object.value47 : player.targetLeaderPos.y

// DeathEvent Aliases
private alias object.drawOrder : deathEvent.drawOrder
private alias object.state	   : deathEvent.state
private alias object.value1	   : deathEvent.leftTextPos
private alias object.value2	   : deathEvent.rightTextPos
private alias object.value3	   : deathEvent.timer

// DeathEvent States
private alias 0 : DEATHEVENT_GAMEOVER
private alias 1 : DEATHEVENT_TIMEOVER
private alias 2 : DEATHEVENT_DEATH
private alias 3 : DEATHEVENT_DEATH_TA

// VSGame Aliases
private alias object.state  : vsGame.state
private alias object.value0 : vsGame.timer

// VSGame States
private alias 2 : VSGAME_FADEOUT

// ========================
// Function Declarations
// ========================
reserve function PlayerObject_ProcessPlayer
reserve function PlayerObject_Blank
reserve function PlayerObject_HandleMovement
reserve function PlayerObject_AirAcceleration
reserve function PlayerObject_HandleAirMovement
reserve function PlayerObject_ResetOnFloor
reserve function PlayerObject_StartJump
reserve function PlayerObject_StartSpindash
reserve function PlayerObject_JumpAbility_Tails
reserve function PlayerObject_JumpAbility_Knux
reserve function PlayerObject_HandleGround
reserve function PlayerObject_HandleBored2
reserve function PlayerObject_HandleAir
reserve function PlayerObject_AirCtrlLock
reserve function PlayerObject_HandleRolling
reserve function PlayerObject_RollingJump
reserve function PlayerObject_LookingUp
reserve function PlayerObject_Crouching
reserve function PlayerObject_HandleSpindash
reserve function PlayerObject_HandleTailsFlight
reserve function PlayerObject_KnuxGlideLeft
reserve function PlayerObject_KnuxGlideRight
reserve function PlayerObject_KnuxGlideDrop
reserve function PlayerObject_KnuxGlideSlide
reserve function PlayerObject_KnuxWallClimb
reserve function PlayerObject_KnuxLedgePullUp
reserve function PlayerObject_Hurt
reserve function PlayerObject_Knockback
reserve function PlayerObject_Death
reserve function PlayerObject_Drown
reserve function PlayerObject_HangingBar // Unused - Leftover from CD
reserve function PlayerObject_TubeSwitch
reserve function PlayerObject_Clinging
reserve function PlayerObject_Waterslide
reserve function PlayerObject_HandleFlyCarry
reserve function PlayerObject_HandleContRun
reserve function PlayerObject_InitReplay
reserve function PlayerObject_RestorePowerup
reserve function PlayerObject_ProcessSuperPalS
reserve function PlayerObject_ProcessSuperPalT
reserve function PlayerObject_ProcessSuperPalK
reserve function PlayerObject_UpdatePhysicsState
reserve function PlayerObject_ProcessSuperState
reserve function PlayerObject_CheckHit
reserve function PlayerObject_BadnikBreak
reserve function PlayerObject_Hit
reserve function PlayerObject_FireHit
reserve function PlayerObject_LightningHit
reserve function PlayerObject_ProjectileHit
reserve function PlayerObject_SpikeHit
reserve function PlayerObject_Kill
reserve function PlayerObject_RollAnimSpd
reserve function PlayerObject_WalkAnimSpd
reserve function PlayerObject_RunAnimSpd
reserve function PlayerObject_HandleRollingDecel
reserve function PlayerObject_Transforming
reserve function PlayerObject_SuperTransform
reserve function PlayerObject_BubbleBounce
reserve function PlayerObject_JumpAbility_Sonic
reserve function PlayerObject_StartFlyCarry

// ========================
// Static Values
// ========================
public value PlayerObject_flyCarryLeaderXPos 	= 0
public value PlayerObject_flyCarryLeaderYPos 	= 0
public value PlayerObject_flyCarryBuddyXPos 	= 0
public value PlayerObject_flyCarryBuddyYPos 	= 0
public value PlayerObject_SuperState 			= SUPERSTATE_NONE
public value PlayerObject_SuperRingLossTimer 	= 0
public value PlayerObject_SuperBlendClr 		= 0
public value PlayerObject_SuperBlendTimer 		= 0
public value PlayerObject_ReplayTable 			= 0
public value PlayerObject_ReplayTablePos 		= 0
public value PlayerObject_ReplaySize 			= 0
public value PlayerObject_ReplayFrameCnt 		= 0
public value PlayerObject_ReplayLength 			= 0

// All these below are unused
private value PlayerObject_value13 = 0
private value PlayerObject_value14 = 0
private value PlayerObject_value15 = 0
private value PlayerObject_value16 = 0
private value PlayerObject_value17 = 0
private value PlayerObject_value18 = 0
private value PlayerObject_value19 = 0

// ========================
// Tables
// ========================
public table PlayerObject_SonicSuperPal
	0x2020A0, 0x2040C0, 0x4040E0, 0x6060E0
	0x404080, 0x4060A0, 0x6060E0, 0x8080E0
	0x606060, 0x6080A0, 0x8080E0, 0xA0A0E0
	0x808040, 0x80A0A0, 0xA0A0E0, 0xC0C0E0
	0xA0A040, 0xA0C0A0, 0xC0C0E0, 0xE0E0E0
	0xC0C040, 0xC0E0A0, 0xE0E0E0, 0xE0E0E0
	0xE0E040, 0xE0E0A0, 0xE0E0E0, 0xE0E0E0
	0xE0E060, 0xE0E0E0, 0xE0E0E0, 0xE0E0E0
	0xE0E080, 0xE0E0E0, 0xE0E0E0, 0xE0E0E0
	0xE0E060, 0xE0E0C0, 0xE0E0E0, 0xE0E0E0
	0xE0E040, 0xE0E0A0, 0xE0E0E0, 0xE0E0E0
	0xE0E020, 0xE0E080, 0xE0E0C0, 0xE0E0E0
	0xE0E000, 0xE0E060, 0xE0E0A0, 0xE0E0E0
	0xE0E000, 0xE0E040, 0xE0E080, 0xE0E0C0
	0xE0E000, 0xE0E060, 0xE0E0A0, 0xE0E0E0
	0xE0E000, 0xE0E080, 0xE0E0C0, 0xE0E0E0
end table

public table PlayerObject_SonicSuperAltPal
	0x202080, 0x4040A0, 0x6060C0, 0x8080E0
	0x404060, 0x6060A0, 0x8080E0, 0xA0A0E0
	0x606040, 0x8080A0, 0xA0A0E0, 0xC0C0E0
	0x808040, 0xA0A0A0, 0xC0C0E0, 0xE0E0E0
	0xA0A040, 0xC0C0A0, 0xE0E0E0, 0xE0E0E0
	0xC0C040, 0xE0E0A0, 0xE0E0E0, 0xE0E0E0
	0xE0E040, 0xE0E0A0, 0xE0E0E0, 0xE0E0E0
	0xE0E060, 0xE0E0E0, 0xE0E0E0, 0xE0E0E0
	0xE0E080, 0xE0E0E0, 0xE0E0E0, 0xE0E0E0
	0xE0E060, 0xE0E0C0, 0xE0E0E0, 0xE0E0E0
	0xE0E040, 0xE0E0A0, 0xE0E0E0, 0xE0E0E0
	0xE0E020, 0xE0E080, 0xE0E0C0, 0xE0E0E0
	0xE0E000, 0xE0E060, 0xE0E0A0, 0xE0E0E0
	0xE0E000, 0xE0E040, 0xE0E080, 0xE0E0C0
	0xE0E000, 0xE0E060, 0xE0E0A0, 0xE0E0E0
	0xE0E000, 0xE0E080, 0xE0E0C0, 0xE0E0E0
end table

public table PlayerObject_TailsSuperPal
	0x800000, 0xE08000, 0xE0A000, 0xA06040
	0x800000, 0xE0A020, 0xE0C040, 0xA06040
	0xA06040, 0xE0C040, 0xE0C080, 0xC06040
	0xC06040, 0xE0C080, 0xE0E0A0, 0xE08040
	0xA06040, 0xE0C040, 0xE0C080, 0xC06040
	0x800000, 0xE0A020, 0xE0C040, 0xA06040
end table

public table PlayerObject_TailsSuperAltPal
	0x800000, 0xE08000, 0xE0A000, 0xA06040
	0x800000, 0xE0A020, 0xE0C040, 0xA06040
	0xA06040, 0xE0C040, 0xE0C080, 0xC06040
	0xC06040, 0xE0C080, 0xE0E0A0, 0xE08040
	0xA06040, 0xE0C040, 0xE0C080, 0xC06040
	0x800000, 0xE0A020, 0xE0C040, 0xA06040
end table

public table PlayerObject_KnuxSuperPal
	0x600020, 0xC00020, 0xE04060
	0x802040, 0xE04060, 0xE060A0
	0xA04060, 0xE06080, 0xE080C0
	0xC06080, 0xE080A0, 0xE0A0E0
	0xE080A0, 0xE0A0C0, 0xE0C0E0
	0xE0A0C0, 0xE0C0E0, 0xE0E0E0
	0xE080A0, 0xE0A0C0, 0xE0C0E0
	0xC06080, 0xE080A0, 0xE0A0E0
	0xA04060, 0xE06080, 0xE080C0
	0x802040, 0xE04060, 0xE060A0
end table

public table PlayerObject_KnuxSuperAltPal
	0x600020, 0xC00040, 0xE04080
	0x802040, 0xE04060, 0xE060A0
	0xA04060, 0xE06080, 0xE080C0
	0xC06080, 0xE080A0, 0xE0A0E0
	0xE080A0, 0xE0A0C0, 0xE0C0E0
	0xE0A0C0, 0xE0C0E0, 0xE0E0E0
	0xE080A0, 0xE0A0C0, 0xE0C0E0
	0xC06080, 0xE080A0, 0xE0A0E0
	0xA04060, 0xE06080, 0xE080C0
	0x802040, 0xE04060, 0xE060A0
end table

private table PlayerObject_SonicPhysicsTable
	0x60000, 0xC00,  0x1800, 0x600,  0x8000,  0x600, 0x68000, -0x40000
	0x30000, 0x600,  0xC00,  0x300,  0x4000,  0x300, 0x38000, -0x20000
	0xA0000, 0x3000, 0x6000, 0x1800, 0x10000, 0x600, 0x80000, -0x40000
	0x50000, 0x1800, 0x3000, 0xC00,  0x8000,  0x300, 0x38000, -0x20000
	0xC0000, 0x1800, 0x3000, 0xC00,  0x8000,  0x600, 0x68000, -0x40000
	0x60000, 0xC00,  0x1800, 0x600,  0x4000,  0x300, 0x38000, -0x20000
	0xC0000, 0x1800, 0x3000, 0xC00,  0x8000,  0x600, 0x80000, -0x40000
	0x60000, 0xC00,  0x1800, 0x600,  0x4000,  0x300, 0x38000, -0x20000
end table

private table PlayerObject_TailsPhysicsTable
	0x60000, 0xC00,  0x1800, 0x600,  0x8000,  0x600, 0x68000, -0x40000
	0x30000, 0x600,  0xC00,  0x300,  0x4000,  0x300, 0x38000, -0x20000
	0xA0000, 0x3000, 0x6000, 0x1800, 0x10000, 0x600, 0x80000, -0x40000
	0x50000, 0x1800, 0x3000, 0xC00,  0x8000,  0x300, 0x38000, -0x20000
	0xC0000, 0x1800, 0x3000, 0xC00,  0x8000,  0x600, 0x68000, -0x40000
	0x60000, 0xC00,  0x1800, 0x600,  0x4000,  0x300, 0x38000, -0x20000
	0xC0000, 0x1800, 0x3000, 0xC00,  0x8000,  0x600, 0x80000, -0x40000
	0x60000, 0xC00,  0x1800, 0x600,  0x4000,  0x300, 0x38000, -0x20000
end table

private table PlayerObject_KnuxPhysicsTable
	0x60000, 0xC00,  0x1800, 0x600,  0x8000,  0x600, 0x60000, -0x40000
	0x30000, 0x600,  0xC00,  0x300,  0x4000,  0x300, 0x30000, -0x20000
	0xA0000, 0x3000, 0x6000, 0x1800, 0x10000, 0x600, 0x60000, -0x40000
	0x50000, 0x1800, 0x3000, 0xC00,  0x8000,  0x300, 0x30000, -0x20000
	0xC0000, 0x1800, 0x3000, 0xC00,  0x8000,  0x600, 0x60000, -0x40000
	0x60000, 0xC00,  0x1800, 0x600,  0x4000,  0x300, 0x30000, -0x20000
	0xC0000, 0x1800, 0x3000, 0xC00,  0x8000,  0x600, 0x60000, -0x40000
	0x60000, 0xC00,  0x1800, 0x600,  0x8000,  0x300, 0x30000, -0x20000
end table


// ========================
// Function Definitions
// ========================

// Initialize the character object for replay playback
function PlayerObject_InitReplay
	PlayerObject_ReplayTablePos = 2
	PlayerObject_ReplayFrameCnt = 1

	currentPlayer = 0
	while currentPlayer < playerCount
		GetTableValue(player[currentPlayer].xpos, 0, PlayerObject_ReplayTable)
		GetTableValue(player[currentPlayer].ypos, 1, PlayerObject_ReplayTable)
		player[currentPlayer].controlMode = -1
		player[currentPlayer].up 		= false
		player[currentPlayer].down 		= false
		player[currentPlayer].left 		= false
		player[currentPlayer].right 	= false
		player[currentPlayer].jumpPress = false
		player[currentPlayer].jumpHold 	= false
		player[currentPlayer].timer 	= 0
		currentPlayer++
	loop

	screen.cameraX = player[0].ixpos
	screen.cameraY = player[0].iypos
end function


function PlayerObject_RestorePowerup
	switch player[currentPlayer].shield
	case SHIELD_NONE
		ResetObjectEntity(arrayPos0, TypeName[Blank Object], 0, 0, 0)
		break

	case SHIELD_NORMAL
		ResetObjectEntity(arrayPos0, blueShieldType, 0, 0, 0)
		object[arrayPos0].priority = PRIORITY_ACTIVE
		object[arrayPos0].inkEffect = INK_ALPHA
		object[arrayPos0].alpha = 0xA0
		break

	case SHIELD_BUBBLE
		ResetObjectEntity(arrayPos0, TypeName[Bubble Shield], 0, 0, 0)
		object[arrayPos0].priority = PRIORITY_ACTIVE
		break

	case SHIELD_FIRE
		ResetObjectEntity(arrayPos0, TypeName[Fire Shield], 0, 0, 0)
		object[arrayPos0].priority = PRIORITY_ACTIVE
		break

	case SHIELD_LIGHTNING
		ResetObjectEntity(arrayPos0, TypeName[LightningShield], 0, 0, 0)
		object[arrayPos0].priority = PRIORITY_ACTIVE
		break

	end switch
end function


function PlayerObject_ProcessSuperPalS
	if PlayerObject_SuperState == SUPERSTATE_SUPER
		PlayerObject_SuperBlendTimer++
		if PlayerObject_SuperBlendTimer >= 4
			PlayerObject_SuperBlendTimer = 0

			PlayerObject_SuperBlendClr += 4
			if PlayerObject_SuperBlendClr >= 64
				PlayerObject_SuperBlendClr = 24
			end if
		end if
	else
		PlayerObject_SuperBlendTimer++
		if PlayerObject_SuperBlendTimer >= 8
			PlayerObject_SuperBlendTimer = 0

			PlayerObject_SuperBlendClr -= 4
			if PlayerObject_SuperBlendClr <= 0
				PlayerObject_SuperBlendClr = 0
				PlayerObject_SuperState = SUPERSTATE_NONE
			end if

			if PlayerObject_SuperBlendClr >= 24
				PlayerObject_SuperBlendClr = 24
			end if
		end if
	end if

	temp1 = PlayerObject_SuperBlendClr

	GetTableValue(temp0, temp1, PlayerObject_SonicSuperPal)
	SetPaletteEntry(0, 2, temp0)
	GetTableValue(temp0, temp1, PlayerObject_SonicSuperAltPal)
	SetPaletteEntry(1, 2, temp0)
	temp1++

	GetTableValue(temp0, temp1, PlayerObject_SonicSuperPal)
	SetPaletteEntry(0, 3, temp0)
	GetTableValue(temp0, temp1, PlayerObject_SonicSuperAltPal)
	SetPaletteEntry(1, 3, temp0)
	temp1++

	GetTableValue(temp0, temp1, PlayerObject_SonicSuperPal)
	SetPaletteEntry(0, 4, temp0)
	GetTableValue(temp0, temp1, PlayerObject_SonicSuperAltPal)
	SetPaletteEntry(1, 4, temp0)
	temp1++

	GetTableValue(temp0, temp1, PlayerObject_SonicSuperPal)
	SetPaletteEntry(0, 5, temp0)
	GetTableValue(temp0, temp1, PlayerObject_SonicSuperAltPal)
	SetPaletteEntry(1, 5, temp0)
end function


function PlayerObject_ProcessSuperPalT
	if PlayerObject_SuperState == SUPERSTATE_SUPER
		PlayerObject_SuperBlendTimer++
		if PlayerObject_SuperBlendTimer >= 12
			PlayerObject_SuperBlendTimer = 0

			PlayerObject_SuperBlendClr += 4
			if PlayerObject_SuperBlendClr >= 24
				PlayerObject_SuperBlendClr = 0
			end if
		end if
	else
		if PlayerObject_SuperBlendClr > 12
			FlipSign(PlayerObject_SuperBlendClr)
			PlayerObject_SuperBlendClr += 24
		end if

		PlayerObject_SuperBlendTimer++
		if PlayerObject_SuperBlendTimer >= 12
			PlayerObject_SuperBlendTimer = 0

			PlayerObject_SuperBlendClr -= 4
			if PlayerObject_SuperBlendClr <= 0
				PlayerObject_SuperBlendClr = 0
				PlayerObject_SuperState = SUPERSTATE_NONE
			end if
		end if
	end if

	temp1 = PlayerObject_SuperBlendClr

	GetTableValue(temp0, temp1, PlayerObject_TailsSuperPal)
	SetPaletteEntry(0, 13, temp0)
	GetTableValue(temp0, temp1, PlayerObject_TailsSuperAltPal)
	SetPaletteEntry(1, 13, temp0)
	temp1++

	GetTableValue(temp0, temp1, PlayerObject_TailsSuperPal)
	SetPaletteEntry(0, 17, temp0)
	GetTableValue(temp0, temp1, PlayerObject_TailsSuperAltPal)
	SetPaletteEntry(1, 17, temp0)
	temp1++

	GetTableValue(temp0, temp1, PlayerObject_TailsSuperPal)
	SetPaletteEntry(0, 18, temp0)
	GetTableValue(temp0, temp1, PlayerObject_TailsSuperAltPal)
	SetPaletteEntry(1, 18, temp0)
	temp1++

	GetTableValue(temp0, temp1, PlayerObject_TailsSuperPal)
	SetPaletteEntry(0, 16, temp0)
	GetTableValue(temp0, temp1, PlayerObject_TailsSuperAltPal)
	SetPaletteEntry(1, 16, temp0)
end function


function PlayerObject_ProcessSuperPalK
	if PlayerObject_SuperState == SUPERSTATE_SUPER
		PlayerObject_SuperBlendTimer++
		if PlayerObject_SuperBlendTimer >= 12
			PlayerObject_SuperBlendTimer = 9

			PlayerObject_SuperBlendClr += 3
			if PlayerObject_SuperBlendClr >= 30
				PlayerObject_SuperBlendTimer = 0
				PlayerObject_SuperBlendClr = 0
			end if
		end if
	else
		if PlayerObject_SuperBlendClr > 15
			FlipSign(PlayerObject_SuperBlendClr)
			PlayerObject_SuperBlendClr += 30
		end if

		PlayerObject_SuperBlendTimer++
		if PlayerObject_SuperBlendTimer >= 12
			PlayerObject_SuperBlendTimer = 0

			PlayerObject_SuperBlendClr -= 3
			if PlayerObject_SuperBlendClr <= 0
				PlayerObject_SuperBlendClr = 0
				PlayerObject_SuperState = SUPERSTATE_NONE
			end if
		end if
	end if

	temp1 = PlayerObject_SuperBlendClr

	GetTableValue(temp0, temp1, PlayerObject_KnuxSuperPal)
	SetPaletteEntry(0, 26, temp0)
	GetTableValue(temp0, temp1, PlayerObject_KnuxSuperAltPal)
	SetPaletteEntry(1, 26, temp0)
	temp1++

	GetTableValue(temp0, temp1, PlayerObject_KnuxSuperPal)
	SetPaletteEntry(0, 27, temp0)
	GetTableValue(temp0, temp1, PlayerObject_KnuxSuperAltPal)
	SetPaletteEntry(1, 27, temp0)
	temp1++

	GetTableValue(temp0, temp1, PlayerObject_KnuxSuperPal)
	SetPaletteEntry(0, 28, temp0)
	GetTableValue(temp0, temp1, PlayerObject_KnuxSuperAltPal)
	SetPaletteEntry(1, 28, temp0)
end function


function PlayerObject_UpdatePhysicsState
	switch stage.playerListPos
	case PlayerName[SONIC]
	case PlayerName[SONIC AND TAILS]
		temp0 = PlayerObject_SonicPhysicsTable
		break

	case PlayerName[TAILS]
		temp0 = PlayerObject_TailsPhysicsTable
		break

	case PlayerName[KNUCKLES]
		temp0 = PlayerObject_KnuxPhysicsTable
		break
	end switch

	temp1 = 0
	temp2 = 0
	if stage.state != STAGE_FROZEN
		temp3 = player[currentPlayer].ypos
		temp3 >>= 16
		CheckGreater(temp3, stage.waterLevel)
		temp4 = checkResult
		CheckNotEqual(player[currentPlayer].type, TypeName[Debug Mode])
		temp4 &= checkResult
		if temp4 == true
			SetBit(temp1, 0, true)
			player[currentPlayer].gravityStrength = 0x1000
		else
			player[currentPlayer].gravityStrength = 0x3800
		end if

		if PlayerObject_SuperState == SUPERSTATE_SUPER
			SetBit(temp1, 1, true)
			temp2 = 2
		end if

		if player[currentPlayer].speedShoesTimer > 0
			SetBit(temp1, 2, true)
			temp2 = 1
		end if

		temp1 <<= 3
	end if

	GetTableValue(player[currentPlayer].topSpeed, temp1, temp0)
	temp1++
	GetTableValue(player[currentPlayer].acceleration, temp1, temp0)
	player[currentPlayer].deceleration = player[currentPlayer].acceleration
	player[currentPlayer].deceleration >>= temp2
	temp1++
	GetTableValue(player[currentPlayer].airAcceleration, temp1, temp0)
	temp1++
	GetTableValue(player[currentPlayer].airDeceleration, temp1, temp0)
	temp1++
	GetTableValue(player[currentPlayer].skidSpeed, temp1, temp0)
	temp1++
	GetTableValue(player[currentPlayer].rollingFriction, temp1, temp0)
	temp1++
	GetTableValue(player[currentPlayer].jumpStrength, temp1, temp0)
	temp1++
	GetTableValue(player[currentPlayer].jumpCap, temp1, temp0)
end function


function PlayerObject_ProcessSuperState
	if PlayerObject_SuperState != SUPERSTATE_NONE
		switch stage.playerListPos
		case PlayerName[SONIC]
		case PlayerName[SONIC AND TAILS]
			CallFunction(PlayerObject_ProcessSuperPalS)
			break

		case PlayerName[TAILS]
			CallFunction(PlayerObject_ProcessSuperPalT)
			break

		case PlayerName[KNUCKLES]
			CallFunction(PlayerObject_ProcessSuperPalK)
			break
		end switch
	end if

	if PlayerObject_SuperState == SUPERSTATE_SUPER
		player.invincibleTimer = 60
		PlayerObject_SuperRingLossTimer++
		if PlayerObject_SuperRingLossTimer == 60
			PlayerObject_SuperRingLossTimer = 0

			player.rings--
			if player.rings <= 0
				player.rings = 0
				PlayerObject_SuperState = SUPERSTATE_FADEOUT
			end if
		end if
	end if

	if PlayerObject_SuperState == SUPERSTATE_FADEOUT
		if stage.playerListPos == PlayerName[SONIC]
			// Restore the normal Sonic sprites
			LoadAnimation("Sonic.ani")
		end if

		if music.currentTrack == TRACK_SUPER
			PlayMusic(TRACK_STAGE)
		end if

		player.invincibleTimer = 0
		currentPlayer = object.entityPos
		if object.state != PlayerObject_Death
			if object.state != PlayerObject_Drown
				arrayPos0 = currentPlayer
				arrayPos0 += playerCount
				CallFunction(PlayerObject_RestorePowerup)
			end if
		end if

		PlayerObject_SuperState = SUPERSTATE_END
		CallFunction(PlayerObject_UpdatePhysicsState)
	end if
end function


function PlayerObject_CheckHit
	CheckEqual(player[currentPlayer].animation, ANI_JUMPING)
	temp0 = checkResult
	CheckEqual(player[currentPlayer].animation, ANI_SPINDASH)
	temp0 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_GLIDING)
	temp0 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_GLIDING_STOP)
	temp0 |= checkResult
	CheckNotEqual(player[currentPlayer].invincibleTimer, 0)
	temp0 |= checkResult

	// Tails can also destroy badniks when flying, but only if the badnik is above him (hitting his tails)
	// So check for that, too
	CheckEqual(player[currentPlayer].animation, ANI_FLYING)
	temp1 = checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLYINGTIRED)
	temp1 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLY_LIFT_UP)
	temp1 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLY_LIFT_DOWN)
	temp1 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLY_LIFT_TIRED)
	temp1 |= checkResult
	if temp1 == true
		CheckGreater(player[currentPlayer].ypos, object.ypos)
		temp0 |= checkResult
	end if

	if temp0 == true
		if player[currentPlayer].gravity == GRAVITY_AIR
			FlipSign(player[currentPlayer].xvel)
			player[currentPlayer].speed = player[currentPlayer].xvel
			player[currentPlayer].yvel += player[currentPlayer].gravityStrength
			player[currentPlayer].yvel += player[currentPlayer].gravityStrength
			FlipSign(player[currentPlayer].yvel)
		end if

		if player[currentPlayer].animation == ANI_GLIDING
			player[currentPlayer].animation = ANI_GLIDING_DROP
			player[currentPlayer].state = PlayerObject_KnuxGlideDrop
		end if

		checkResult = true
	else
		if player[currentPlayer].state != PlayerObject_Death
			if player[currentPlayer].invincibleTimer == 0
				if player[currentPlayer].blinkTimer == 0
					player[currentPlayer].state = PlayerObject_Hurt
					if player[currentPlayer].xpos > object.xpos
						player[currentPlayer].speed = 0x20000
					else
						player[currentPlayer].speed = -0x20000
					end if
				end if
			end if
		end if

		checkResult = false
	end if
end function


function PlayerObject_BadnikBreak
	CheckEqual(player[currentPlayer].animation, ANI_JUMPING)
	temp0 = checkResult
	CheckEqual(player[currentPlayer].animation, ANI_SPINDASH)
	temp0 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_GLIDING)
	temp0 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_GLIDING_STOP)
	temp0 |= checkResult
	CheckNotEqual(player[currentPlayer].invincibleTimer, 0)
	temp0 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLYING)
	temp1 = checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLYINGTIRED)
	temp1 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLY_LIFT_UP)
	temp1 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLY_LIFT_DOWN)
	temp1 |= checkResult
	CheckEqual(player[currentPlayer].animation, ANI_FLY_LIFT_TIRED)
	temp1 |= checkResult
	if temp1 == true
		CheckGreater(player[currentPlayer].ypos, object.ypos)
		temp0 |= checkResult
	end if

	if temp0 == true
		ResetObjectEntity(object.entityPos, TypeName[Blank Object], 0, object.xpos, object.ypos)
		Rand(checkResult, 32)
		if checkResult >= 16
			CreateTempObject(animalType1, 0, object.xpos, object.ypos)
		else
			CreateTempObject(animalType2, 0, object.xpos, object.ypos)
		end if
		object[tempObjectPos].priority = PRIORITY_ACTIVE_SMALL

		CreateTempObject(TypeName[Smoke Puff], 0, object.xpos, object.ypos)
		object[tempObjectPos].drawOrder = 4

		CreateTempObject(TypeName[Object Score], player[currentPlayer].scoreBonus, object.xpos, object.ypos)
		object[tempObjectPos].drawOrder = 4
		
		PlaySfx(SfxName[Destroy], false)

		if player[currentPlayer].yvel > 0
			if player[currentPlayer].ypos >= object.ypos
				player[currentPlayer].yvel -= 0x10000
			else
				player[currentPlayer].yvel += player[currentPlayer].gravityStrength
				player[currentPlayer].yvel += player[currentPlayer].gravityStrength
				FlipSign(player[currentPlayer].yvel)
			end if
		else
			player[currentPlayer].yvel += 0x10000
		end if
		temp1 = arrayPos0
		
		// global variable "array" (yes, this is actually how its done)
		if options.vsMode == false
			temp0 = currentPlayer
			currentPlayer = 0
			arrayPos0 = VarName[player.score]
		else
			arrayPos0 = VarName[player.score]
			arrayPos0 += currentPlayer
		end if

		switch player[currentPlayer].scoreBonus
		case 0
			global[arrayPos0] += 100
			break

		case 1
			global[arrayPos0] += 200
			break

		case 2
			global[arrayPos0] += 500
			break

		case 3
		case 4
		case 5
		case 6
		case 7
		case 8
		case 9
		case 10
		case 11
		case 12
		case 13
		case 14
			global[arrayPos0] += 1000
			break

		case 15
			global[arrayPos0] += 10000
			break
		end switch

		if player[currentPlayer].scoreBonus < 15
			player[currentPlayer].scoreBonus++
		end if

		if options.vsMode == false
			currentPlayer = temp0
		end if
		arrayPos0 = temp1
	else
		if player[currentPlayer].state != PlayerObject_Death
			if player[currentPlayer].invincibleTimer == 0
				if player[currentPlayer].blinkTimer == 0
					player[currentPlayer].state = PlayerObject_Hurt
					if player[currentPlayer].xpos > object.xpos
						player[currentPlayer].speed = 0x20000
					else
						player[currentPlayer].speed = -0x20000
					end if
				end if
			end if
		end if
	end if
end function


function PlayerObject_Hit
	if player[currentPlayer].state != PlayerObject_Death
		arrayPos0 = player[currentPlayer].entityPos
		arrayPos0 += playerCount
		if player[currentPlayer].invincibleTimer == 0
			if player[currentPlayer].blinkTimer == 0
				player[currentPlayer].state = PlayerObject_Hurt
				if player[currentPlayer].xpos > object.xpos
					player[currentPlayer].speed = 0x20000
				else
					player[currentPlayer].speed = -0x20000
				end if
			end if
		end if
	end if
end function


function PlayerObject_FireHit
	if player[currentPlayer].shield != SHIELD_FIRE
		if player[currentPlayer].state != PlayerObject_Death
			arrayPos0 = player[currentPlayer].entityPos
			arrayPos0 += playerCount
			if player[currentPlayer].invincibleTimer == 0
				if player[currentPlayer].blinkTimer == 0
					player[currentPlayer].state = PlayerObject_Hurt
					if player[currentPlayer].xpos > object.xpos
						player[currentPlayer].speed = 0x20000
					else
						player[currentPlayer].speed = -0x20000
					end if
				end if
			end if
		end if
	end if
end function


function PlayerObject_LightningHit
	if player[currentPlayer].shield != SHIELD_LIGHTNING
		if player[currentPlayer].state != PlayerObject_Death
			arrayPos0 = player[currentPlayer].entityPos
			arrayPos0 += playerCount
			if player[currentPlayer].invincibleTimer == 0
				if player[currentPlayer].blinkTimer == 0
					player[currentPlayer].state = PlayerObject_Hurt
					if player[currentPlayer].xpos > object.xpos
						player[currentPlayer].speed = 0x20000
					else
						player[currentPlayer].speed = -0x20000
					end if
				end if
			end if
		end if
	end if
end function


function PlayerObject_ProjectileHit
	if player[currentPlayer].shield > SHIELD_NORMAL // Only elemental shields can relfect projectiles
		temp0 = player[currentPlayer].xpos
		temp0 -= object.xpos

		temp1 = player[currentPlayer].ypos
		temp1 -= object.ypos

		ATan2(temp2, temp0, temp1)
		Sin256(temp0, temp2)
		Cos256(temp1, temp2)

		object.xvel = temp1
		object.xvel *= -0x800
		object.yvel = temp0
		object.yvel *= -0x800
	else
		if player[currentPlayer].state != PlayerObject_Death
			arrayPos0 = player[currentPlayer].entityPos
			arrayPos0 += playerCount

			if player[currentPlayer].invincibleTimer == 0
				if player[currentPlayer].blinkTimer == 0
					player[currentPlayer].state = PlayerObject_Hurt

					if player[currentPlayer].xpos > object.xpos
						player[currentPlayer].speed = 0x20000
					else
						player[currentPlayer].speed = -0x20000
					end if
				end if
			end if
		end if
	end if
end function


function PlayerObject_SpikeHit
	if player[currentPlayer].state != PlayerObject_Death
		arrayPos0 = player[currentPlayer].entityPos
		arrayPos0 += playerCount

		if player[currentPlayer].invincibleTimer == 0
			if player[currentPlayer].state != PlayerObject_Hurt
				if player[currentPlayer].state != PlayerObject_Knockback

					// Check for spike bug and player invulnerability
					temp0 = options.spikeBehavior
					CheckEqual(player[currentPlayer].blinkTimer, 0)
					temp0 |= checkResult

					if temp0 == true
						if player[currentPlayer].blinkTimer == 0
							player[currentPlayer].blinkTimer = 2
						end if

						player[currentPlayer].state = PlayerObject_Hurt
						if player[currentPlayer].xpos > object.xpos
							player[currentPlayer].speed = 0x20000
						else
							player[currentPlayer].speed = -0x20000
						end if
					end if
				end if
			end if
		end if
	end if
end function


function PlayerObject_Kill
	PlaySfx(SfxName[Hurt], false)

	player[currentPlayer].speed = 0
	player[currentPlayer].xvel = 0
	player[currentPlayer].yvel = -0x68000
	player[currentPlayer].state = PlayerObject_Death
	player[currentPlayer].animation = ANI_DYING
	player[currentPlayer].tileCollisions = false
	player[currentPlayer].interaction = false
	player[currentPlayer].blinkTimer = 0
	player[currentPlayer].visible = true
	player[currentPlayer].sortedDrawOrder = 6

	if options.vsMode == false
		if currentPlayer == 0
			// If P1 is the one who died, then freeze everything else

			player[currentPlayer].priority = PRIORITY_ACTIVE_PAUSED
			if player[1].type == TypeName[Player 2 Object]
				player[1].priority = PRIORITY_ACTIVE_PAUSED
			end if

			screen.cameraEnabled = false
			stage.state = STAGE_FROZEN
		end if
	else
		if currentPlayer == screen.cameraTarget
			screen.cameraEnabled = false
		end if
	end if

	// Move to the shield object slot
	arrayPos0 = currentPlayer
	arrayPos0 += playerCount

	if object[arrayPos0].type == invincibilityType
		// This... doesn't actually seem to do anything
		object[arrayPos0].propertyValue = 3
	end if

	// Remove the player's shield
	object[arrayPos0].type = TypeName[Blank Object]
	player[currentPlayer].shield = SHIELD_NONE
end function


function PlayerObject_ProcessPlayer
	if options.attractMode == false
		if player.controlMode == 0
			// No control lock active right now, process player control

			// Check if the player's touched the bottom left of the screen
			CheckTouchRect(0, 96, screen.xcenter, screen.ysize)

			if checkResult > -1
				arrayPos0 = checkResult

				temp0 = touchscreen[arrayPos0].xpos
				temp0 -= saveRAM[39] // Virtual DPad X Pos

				temp1 = touchscreen[arrayPos0].ypos
				temp1 -= saveRAM[40] // Virtual DPad Y Pos

				ATan2(temp2, temp0, temp1)
				temp2 += 32
				temp2 &= 255
				temp2 >>= 6

				switch temp2
				case 0
					inputDown.right = true
					break

				case 1
					inputDown.down = true
					break

				case 2
					inputDown.left = true
					break

				case 3
					inputDown.up = true
					break
				end switch
			end if

			// And now check if the player's touched the jump button portion of the touch screen
			CheckTouchRect(screen.xcenter, 96, screen.xsize, 240)

			if checkResult > -1
				inputDown.buttonA = true
			end if

			// Update touchJump
			// (touchJump is the state of the touchscreen jump button the previous frame)
			if touchJump == false
				inputPress.buttonA |= inputDown.buttonA
			end if
			touchJump = inputDown.buttonA

			if stage.debugMode == true
				// If in Debug Mode, check for the item switcher button too
				CheckTouchRect(0, 0, 112, 56)
				if checkResult > -1
					inputDown.buttonB = true
				end if

				// Update touchDebug too, it's the B button equivalent of touchJump
				if touchDebug == false
					inputPress.buttonB |= inputDown.buttonB
				end if
				touchDebug = inputDown.buttonB
			end if

			// Check for the pause button being pressed as well
			CheckTouchRect(240, 0, screen.xsize, 40)
			if checkResult > -1
				if options.vsMode == false
					PlaySfx(SfxName[Menu Back], false)
					StopSfx(SfxName[Flying])
					StopSfx(SfxName[Tired])
					engine.state = ENGINE_INITPAUSE
				end if
			end if

			if inputPress.start == true
				if options.vsMode == false
					PlaySfx(SfxName[Menu Back], false)
					StopSfx(SfxName[Flying])
					StopSfx(SfxName[Tired])
					engine.state = ENGINE_INITPAUSE
				end if
			end if
		end if

		// Call the function for supporting physical gamepads as well
		ProcessObjectControl()

		if options.vsMode == true
			// If in comp mode, send over the player at this point
			CallNativeFunction2(SendEntity, 0, false)
		end if
	else
		// No pausing during credits
		// (I don't think this actually does anything, though..?)
		if credits.screen == 0

			// Allow skipping of the demo by pausing
			CheckTouchRect(0, 0, screen.xsize, screen.ysize)
			if inputPress.start == true
				checkResult = 0
			end if

			if checkResult > -1
				if PlayerObject_ReplayLength > 1
					PlayerObject_ReplayLength = 1
				end if
			end if

			if inputPress.start == true
				if PlayerObject_ReplayLength > 1
					PlayerObject_ReplayLength = 1
				end if
			end if
		end if

		if player.controlMode == 0
			PlayerObject_ReplayFrameCnt--
			if PlayerObject_ReplayFrameCnt < 1
				if PlayerObject_ReplayTablePos < PlayerObject_ReplaySize
					GetTableValue(temp0, PlayerObject_ReplayTablePos, PlayerObject_ReplayTable)
					GetBit(player.up, temp0, 0)
					GetBit(player.down, temp0, 1)
					GetBit(player.left, temp0, 2)
					GetBit(player.right, temp0, 3)
					GetBit(player.jumpPress, temp0, 4)
					GetBit(player.jumpHold, temp0, 5)
					PlayerObject_ReplayTablePos++
					GetTableValue(PlayerObject_ReplayFrameCnt, PlayerObject_ReplayTablePos, PlayerObject_ReplayTable)
					PlayerObject_ReplayTablePos++
				end if
			else
				if player.jumpPress == true
					player.jumpPress = false
				end if
			end if

			if PlayerObject_ReplayLength > 0
				PlayerObject_ReplayLength--
				if PlayerObject_ReplayLength < 1
					ResetObjectEntity(11, TypeName[Title Card], 0, 0, 0)
					object[11].state = 8
					object[11].priority = PRIORITY_ACTIVE
					object[11].drawOrder = 6
					player.invincibleTimer = 80
					screen.cameraEnabled = 0
				end if
			end if
		end if
	end if
	
	if player.speedShoesTimer > 0
		player.speedShoesTimer--
		if player.speedShoesTimer < 1
			currentPlayer = player.entityPos
			CallFunction(PlayerObject_UpdatePhysicsState)

			// If any player has speed shoes, keep the sped-up music
			temp0 = false
			foreach (GROUP_PLAYERS, currentPlayer, ACTIVE_ENTITIES)
				temp0 += player[currentPlayer].speedShoesTimer
			next

			if temp0 == false
				if SlowDownMusic != 0
					CallFunction(SlowDownMusic)
				end if
			end if

			player.speedShoesTimer = 0
		end if
	end if

	if player.state != PlayerObject_Knockback
		if player.blinkTimer > 0
			player.blinkTimer--

			GetBit(temp0, player.blinkTimer, 2)
			if temp0 == true
				player.visible = false
			else
				player.visible = true
			end if
		end if
	end if

	if player.invincibleTimer > 0
		player.invincibleTimer--
		if player.invincibleTimer == 0

			// If any player is invincible, continue playing the invincibility music
			temp0 = false
			foreach (GROUP_PLAYERS, currentPlayer, ACTIVE_ENTITIES)
				temp0 += player[currentPlayer].invincibleTimer
			next

			if temp0 == false
				if music.currentTrack == TRACK_INVINCIBLE
					PlayMusic(TRACK_STAGE)
				end if
			end if

			if object[+playerCount].type == invincibilityType
				currentPlayer = player.entityPos
				arrayPos0 = currentPlayer
				arrayPos0 += playerCount
				CallFunction(PlayerObject_RestorePowerup)
			end if
		end if
	end if

	if player.state != PlayerObject_LookingUp
		if player.state != PlayerObject_Crouching
			// Move the camera back to its normal position
			if player.lookPosY > 0
				player.lookPosY -= 2
			end if

			if player.lookPosY < 0
				player.lookPosY += 2
			end if
		end if
	end if

	// After a spindash release, restore the camera back to normal after a few short moments
	if player.scrollDelay > 0
		player.scrollDelay--

		if player.scrollDelay == 0
			if player.entityPos == screen.cameraTarget
				screen.cameraStyle = 0 // Set the camera state to unlocked
			end if
		end if
	end if

	if player.state != PlayerObject_HandleTailsFlight
		if player.flightVelocity != 0
			// As a fail-safe, if not flying, enfore that the SFX stop playing as well
			StopSfx(SfxName[Flying])
			StopSfx(SfxName[Tired])
			player.flightVelocity = 0
		end if
	end if
end function


function PlayerObject_Blank
	checkResult = false
end function


function PlayerObject_RollAnimSpd
	if player.character == PlayerName[TAILS]
		// Tails gets a constant 120
		player.customRollAnimSpeed = 120
	else
		// S&K get anim speeds dependant on their actual speed
		player.customRollAnimSpeed = player.speed
		if player.customRollAnimSpeed < 0
			FlipSign(player.customRollAnimSpeed)
		end if

		player.customRollAnimSpeed *= 240
		player.customRollAnimSpeed /= 0x60000
		player.customRollAnimSpeed += 48
	end if
end function


function PlayerObject_WalkAnimSpd
	player.animationSpeed = player.speed

	if player.animationSpeed < 0
		FlipSign(player.animationSpeed)
	end if

	player.animationSpeed *= 60
	player.animationSpeed /= 0x60000
	player.animationSpeed += 20
end function


function PlayerObject_RunAnimSpd
	player.animationSpeed = player.speed

	if player.animationSpeed < 0
		FlipSign(player.animationSpeed)
	end if

	player.animationSpeed *= 80
	player.animationSpeed /= 0x60000
end function


function PlayerObject_HandleMovement
	if player.controlLock > 0
		// No moving while the control lock is active, simply just adjust player speed dependong on their angle for right now
		player.controlLock--
		Sin256(temp0, player.angle)
		temp0 *= 0x2000
		temp0 >>= 8
		player.speed += temp0
	else
		if player.left == true
			temp0 = player.topSpeed
			FlipSign(temp0)
			if player.speed > temp0
				if player.speed > 0
					if player.collisionMode == CMODE_FLOOR
						if player.speed > 0x40000
							player.skidding = 16
						end if
					end if

					if player.speed < player.skidSpeed
						player.speed = player.skidSpeed
						FlipSign(player.speed)
						player.skidding = 0
					else
						player.speed -= player.skidSpeed
					end if
				else
					player.speed -= player.acceleration
					player.skidding = 0
				end if
			end if

			if player.speed <= 0
				player.direction = FLIP_X
			end if
		end if

		if player.right == true
			if player.speed < player.topSpeed
				if player.speed < 0
					if player.collisionMode == CMODE_FLOOR
						if player.speed < -0x40000
							player.skidding = 16
						end if
					end if

					temp0 = player.skidSpeed
					FlipSign(temp0)
					if player.speed > temp0
						player.speed = player.skidSpeed
						player.skidding = 0
					else
						player.speed += player.skidSpeed
					end if
				else
					player.speed += player.acceleration
					player.skidding = 0
				end if
			end if

			if player.speed >= 0
				player.direction = FLIP_NONE
			end if
		end if

		temp0 = player.left
		temp0 |= player.right
		if temp0 == false
			if player.speed > 0
				player.speed -= player.deceleration
				if player.speed < 0
					player.speed = 0
				end if
			else
				player.speed += player.deceleration
				if player.speed > 0
					player.speed = 0
				end if
			end if

			if player.speed > 0x2000
				Sin256(temp0, player.angle)
				temp0 *= 0x2000
				temp0 >>= 8
				player.speed += temp0
			end if

			if player.speed < -0x2000
				Sin256(temp0, player.angle)
				temp0 *= 0x2000
				temp0 >>= 8
				player.speed += temp0
			end if

			if player.angle > 192
				if player.angle < 228
					if player.speed > -0x10000
						if player.speed < 0x10000
							player.controlLock = 30
						end if
					end if
				end if
			end if

			if player.angle > 28
				if player.angle < 64
					if player.speed > -0x10000
						if player.speed < 0x10000
							player.controlLock = 30
						end if
					end if
				end if
			end if
		else
			Sin256(temp0, player.angle)
			temp0 *= 0x2000
			temp0 >>= 8
			player.speed += temp0
			if player.right == true
				if player.left == false
					if player.angle > 192
						if player.angle < 228
							if player.speed < 0x28000
								if player.speed > -0x20000
									player.controlLock = 30
								end if
							end if
						end if
					end if
				end if
			else
				if player.left == true
					if player.angle > 28
						if player.angle < 64
							if player.speed > -0x28000
								if player.speed < 0x20000
									player.controlLock = 30
								end if
							end if
						end if
					end if
				end if
			end if
		end if

		if options.speedCap == true
			// Enforce the speed cap
			if player.left == true
				temp0 = player.topSpeed
				FlipSign(temp0)
				if player.speed < temp0
					player.speed = temp0
				end if
			end if

			if player.right == true
				if player.speed > player.topSpeed
					player.speed = player.topSpeed
				end if
			end if
		end if
	end if

	switch player.collisionMode
	case CMODE_LWALL
		if player.angle <= 192
			if player.speed > -0x20000
				if player.speed < 0x20000
					player.gravity = GRAVITY_AIR
					player.angle = 0
					player.collisionMode = CMODE_FLOOR
					player.speed = player.xvel
				end if
			end if
		end if
		break

	case CMODE_ROOF
		if player.speed > -0x20000
			if player.speed < 0x20000
				player.gravity = GRAVITY_AIR
				player.angle = 0
				player.collisionMode = CMODE_FLOOR
				player.speed = player.xvel
			end if
		end if
		break

	case CMODE_RWALL
		if player.angle >= 64
			if player.speed > -0x20000
				if player.speed < 0x20000
					player.gravity = GRAVITY_AIR
					player.angle = 0
					player.collisionMode = CMODE_FLOOR
					player.speed = player.xvel
				end if
			end if
		end if
		break

	end switch
end function


function PlayerObject_AirAcceleration
	if player.yvel > -0x40000
		if player.yvel < 0
			temp0 = player.speed
			temp0 >>= 5
			player.speed -= temp0
		end if
	end if

	temp0 = player.topSpeed
	FlipSign(temp0)
	if player.speed > temp0
		if player.left == true
			player.speed -= player.airAcceleration
			player.direction = FLIP_X
		end if
	else
		if player.left == true
			player.direction = FLIP_X
		end if
	end if

	if player.speed < player.topSpeed
		if player.right == true
			player.speed += player.airAcceleration
			player.direction = FLIP_NONE
		end if
	else
		if player.right == true
			player.direction = FLIP_NONE
		end if
	end if

	if options.airSpeedCap == true
		if player.left == true
			temp0 = player.topSpeed
			FlipSign(temp0)
			if player.speed < temp0
				player.speed = temp0
			end if
		end if

		if player.right == true
			if player.speed > player.topSpeed
				player.speed = player.topSpeed
			end if
		end if
	end if
end function


function PlayerObject_HandleRollingDecel
	if player.right == true
		if player.speed < 0
			player.speed += player.rollingDeceleration
		end if
	end if

	if player.left == true
		if player.speed > 0
			player.speed -= player.rollingDeceleration
		end if
	end if

	temp1 = player.speed
	if player.speed > 0
		player.speed -= player.rollingFriction
		Sin256(temp0, player.angle)
		if temp0 > 0
			Sin256(temp0, player.angle)
			temp0 *= 0x5000
		else
			Sin256(temp0, player.angle)
			temp0 *= 0x1400
		end if
		temp0 >>= 8
		player.speed += temp0
		if player.speed > 0x120000
			player.speed = 0x120000
		end if
	else
		player.speed += player.rollingFriction

		Sin256(temp0, player.angle)
		if temp0 < 0
			Sin256(temp0, player.angle)
			temp0 *= 0x5000
		else
			Sin256(temp0, player.angle)
			temp0 *= 0x1400
		end if
		temp0 >>= 8

		player.speed += temp0
		if player.speed < -0x120000
			player.speed = -0x120000
		end if
	end if

	switch player.collisionMode
	case CMODE_FLOOR
	case CMODE_ROOF
		if temp1 > 0
			if player.speed < 0
				player.speed = 0
				player.state = PlayerObject_HandleGround
			end if
		else
			if player.speed > 0
				player.speed = 0
				player.state = PlayerObject_HandleGround
			end if
		end if
		break

	case CMODE_LWALL
		if player.angle < 193
			if temp1 > 0
				if player.speed < 0x20000
					player.gravity = GRAVITY_AIR
					player.xvel = 0
					player.speed = 0
				end if
			end if
		end if
		break

	case CMODE_RWALL
		if player.angle > 63
			if temp1 < 0
				if player.speed > -0x20000
					player.gravity = GRAVITY_AIR
					player.xvel = 0
					player.speed = 0
				end if
			end if
		end if
		break

	end switch
end function


function PlayerObject_HandleAirMovement
	player.scrollTracking = true
	player.yvel += player.gravityStrength
	if object.yvel < player.jumpCap
		if object.jumpHold == false
			if player.timer > 0
				object.yvel = player.jumpCap
				temp0 = object.speed
				temp0 >>= 5
				object.speed -= temp0
			end if
		end if
	end if
	object.xvel = object.speed

	if object.rotation < 256
		if object.rotation > 0
			object.rotation -= 4
		else
			object.rotation = 0
		end if
	else
		if object.rotation < 512
			object.rotation += 4
		else
			object.rotation = 0
		end if
	end if

	object.collisionMode = CMODE_FLOOR
	if object.animation == ANI_JUMPING
		object.animationSpeed = player.customRollAnimSpeed
	end if
end function


function PlayerObject_ResetOnFloor
	object.scrollTracking = 0
	Cos256(temp0, object.angle)
	temp0 *= object.speed
	temp0 >>= 8
	object.xvel = temp0

	Sin256(temp0, object.angle)
	temp0 *= object.speed
	temp0 >>= 8
	object.yvel = temp0
end function


function PlayerObject_StartJump

	// Let's mind our head!!!
	temp1 = false
	if object.collisionMode == CMODE_FLOOR
		temp6 = object.xpos
		temp7 = object.ypos
		temp0 = object.collisionTop
		temp0 -= 2
		ObjectTileCollision(CSIDE_ROOF, 0, temp0, object.collisionPlane)
		
		temp1 = checkResult
		object.xpos = temp6
		object.ypos = temp7
		temp0 = object.collisionBottom
		if object.animation != ANI_JUMPING
			object.iypos -= player.jumpOffset
			temp0 += player.jumpOffset
		end if
		ObjectTileCollision(CSIDE_FLOOR, 0, temp0, object.collisionPlane)
	end if

	if temp1 == false
		object.controlLock = 0
		object.gravity = GRAVITY_AIR
		temp1 = player.jumpStrength
		temp1 += player.gravityStrength
		Sin256(object.xvel, object.angle)
		object.xvel *= temp1
		Cos256(temp0, object.angle)
		temp0 *= object.speed
		object.xvel += temp0
		object.xvel >>= 8

		Sin256(object.yvel, object.angle)
		object.yvel *= object.speed
		Cos256(temp0, object.angle)
		temp0 *= temp1
		object.yvel -= temp0
		object.yvel >>= 8

		object.speed = object.xvel
		object.scrollTracking = true
		object.animation = ANI_JUMPING
		object.angle = 0
		object.collisionMode = CMODE_FLOOR
		player.timer = 1
		CallFunction(PlayerObject_RollAnimSpd)

		if object.state == PlayerObject_HandleRolling
			object.state = PlayerObject_RollingJump
		else
			object.state = PlayerObject_HandleAir
		end if

		PlaySfx(SfxName[Jump], false)
		player.collisionDisabled = true
		player.jumpAbilityState = 1
	end if
end function


function PlayerObject_StartSpindash
	object.state = PlayerObject_HandleSpindash
	object.animation = ANI_SPINDASH
	player.abilityTimer = 0
	PlaySfx(SfxName[Charge], false)

	CreateTempObject(TypeName[Dust Puff], object.entityPos, object.xpos, object.ypos)
	object[tempObjectPos].iypos = object.collisionBottom
	object[tempObjectPos].ypos += object.ypos
	object[tempObjectPos].frame = 4
	object[tempObjectPos].drawOrder = 4
	object[tempObjectPos].direction = object.direction
end function


function PlayerObject_Transforming
	player.collisionDisabled = true

	player.timer--
	if player.timer == 0
		object.state = PlayerObject_HandleAir
		object.animation = ANI_WALKING
	end if
end function


function PlayerObject_SuperTransform
	if stage.timeEnabled == true

		// Move to the shield object slot and spawn a Super Spark there
		arrayPos0 = currentPlayer
		arrayPos0 += playerCount
		ResetObjectEntity(arrayPos0, TypeName[Super Spark], 0, player[0].xpos, player[0].ypos)
		object[arrayPos0].priority = PRIORITY_ACTIVE

		PlaySfx(SfxName[Transform], false)
		PlayMusic(TRACK_SUPER)

		PlayerObject_SuperState = SUPERSTATE_SUPER
		player[currentPlayer].invincibleTimer = 60
		player[currentPlayer].blinkTimer = 0
		player[currentPlayer].visible = true

		CallFunction(PlayerObject_UpdatePhysicsState)
		if stage.playerListPos == PlayerName[SONIC]
			// If Sonic, load the Super Sprites
			LoadAnimation("SuperSonic.ani")
		end if

		player[currentPlayer].state = PlayerObject_Transforming
		player[currentPlayer].collisionDisabled = true
		player[currentPlayer].animation = ANI_SUPER_TRANSFORM
		player[currentPlayer].timer = 24
	end if
end function


function PlayerObject_BubbleBounce
	CallFunction(PlayerObject_AirAcceleration)
	CheckNotEqual(player.shield, SHIELD_BUBBLE)
	temp0 = checkResult
	CheckNotEqual(player.invincibleTimer, 0)
	temp0 |= checkResult
	CheckEqual(PlayerObject_SuperState, SUPERSTATE_SUPER)
	temp0 |= checkResult

	if temp0 == true
		object.state = PlayerObject_HandleAir
	else
		if object.gravity == GRAVITY_AIR
			CallFunction(PlayerObject_HandleAirMovement)
		else
			player.jumpAbilityState = 1
			object.gravity = GRAVITY_AIR
			if player.jumpStrength == 0x38000
				temp1 = -0x40000
			else
				temp1 = -0x78000
			end if
			temp1 += player.gravityStrength
			Sin256(object.xvel, object.angle)
			object.xvel *= temp1
			Cos256(temp0, object.angle)
			temp0 *= object.speed
			object.xvel += temp0
			object.xvel >>= 8

			Sin256(object.yvel, object.angle)
			object.yvel *= object.speed
			Cos256(temp0, object.angle)
			temp0 *= temp1
			object.yvel = temp0
			object.yvel >>= 8

			object.speed = object.xvel
			object.scrollTracking = true
			object.animation = ANI_JUMPING
			object.angle = 0
			object.collisionMode = CMODE_FLOOR
			player.timer = 1
			CallFunction(PlayerObject_RollAnimSpd)
			object.state = PlayerObject_HandleAir
			PlaySfx(SfxName[Bubble Bounce], false)
			object[+playerCount].state = 4
		end if
	end if
end function


function PlayerObject_JumpAbility_Sonic
	if object.jumpPress == true
		CheckEqual(specialStage.emeralds, 0b01111111)
		temp0 = checkResult
		CheckGreater(player.rings, 49)
		temp0 &= checkResult
		CheckNotEqual(PlayerObject_SuperState, SUPERSTATE_SUPER)
		temp0 &= checkResult
		CheckNotEqual(object[30].type, TypeName[Act Finish])
		temp0 &= checkResult

		if temp0 == true
			currentPlayer = object.entityPos
			CallFunction(PlayerObject_SuperTransform)
		else
			CheckEqual(player.invincibleTimer, 0)
			temp0 = checkResult
			CheckNotEqual(PlayerObject_SuperState, SUPERSTATE_SUPER)
			temp0 &= checkResult

			if temp0 == true
				switch player.shield
				case SHIELD_NONE
					temp0 = options.shieldType
					temp0 &= 1
					if temp0 > 0
						PlaySfx(SfxName[Insta Shield], false)
						if object[+playerCount].type == TypeName[Blank Object]
							currentPlayer = object.entityPos
							arrayPos0 = currentPlayer
							arrayPos0 += playerCount
							ResetObjectEntity(arrayPos0, TypeName[Insta Shield], 0, 0, 0)
							object[arrayPos0].priority = PRIORITY_ACTIVE
						end if

						player.jumpAbilityState = 2
						object[+playerCount].state = 1
						if object.state == PlayerObject_RollingJump
							object.state = PlayerObject_HandleAir
						end if
					end if
					break

				case SHIELD_NORMAL
					break

				case SHIELD_BUBBLE
					PlaySfx(SfxName[Bubble Bounce], false)
					object.yvel = 0x80000
					object.xvel = 0
					object.speed = object.xvel
					player.jumpAbilityState = 2
					object.state = PlayerObject_BubbleBounce
					object[+playerCount].state = 2
					break

				case SHIELD_FIRE
					PlaySfx(SfxName[Fire Dash], false)
					GetBit(temp0, object.direction, 0)
					if temp0 == false
						object.xvel = 0x80000
					else
						object.xvel = -0x80000
					end if

					object.speed = object.xvel
					object.yvel = 0
					player.jumpAbilityState = 2
					if object.entityPos == screen.cameraTarget
						player.scrollDelay = 15
						screen.cameraStyle = 4
					end if

					if object.state == PlayerObject_RollingJump
						object.state = PlayerObject_HandleAir
					end if

					object[+playerCount].state = 2
					object[+playerCount].direction = object.direction
					break

				case SHIELD_LIGHTNING
					PlaySfx(SfxName[Lightning Jump], false)
					object.yvel = -0x58000
					player.jumpAbilityState = 2

					CreateTempObject(TypeName[Lightning Spark], 0, object.xpos, object.ypos)
					object[tempObjectPos].xvel = -0x20000
					object[tempObjectPos].yvel = -0x20000

					CreateTempObject(TypeName[Lightning Spark], 0, object.xpos, object.ypos)
					object[tempObjectPos].xvel = 0x20000
					object[tempObjectPos].yvel = -0x20000

					CreateTempObject(TypeName[Lightning Spark], 0, object.xpos, object.ypos)
					object[tempObjectPos].xvel = -0x20000
					object[tempObjectPos].yvel = 0x20000

					CreateTempObject(TypeName[Lightning Spark], 0, object.xpos, object.ypos)
					object[tempObjectPos].xvel = 0x20000
					object[tempObjectPos].yvel = 0x20000

					if object.state == PlayerObject_RollingJump
						object.state = PlayerObject_HandleAir
					end if
					break
				end switch
			end if
		end if
	end if
end function


function PlayerObject_JumpAbility_Tails
	if object.jumpPress == true
		CheckEqual(specialStage.emeralds, 0b01111111)
		temp0 = checkResult
		CheckGreater(player.rings, 49)
		temp0 &= checkResult
		CheckNotEqual(PlayerObject_SuperState, SUPERSTATE_SUPER)
		temp0 &= checkResult
		CheckNotEqual(object[30].type, TypeName[Act Finish])
		temp0 &= checkResult
		CheckEqual(options.superTails, true)
		temp0 &= checkResult

		if temp0 == true
			currentPlayer = object.entityPos
			CallFunction(PlayerObject_SuperTransform)
		else
			player.timer = 0
			object.state = PlayerObject_HandleTailsFlight
			player.flightVelocity = 0x800

			if player.gravityStrength == 0x3800
				PlaySfx(SfxName[Flying], true)
				object.animation = ANI_FLYING
			else
				object.animation = ANI_SWIMMING
			end if
		end if
	end if
end function


function PlayerObject_JumpAbility_Knux
	if object.jumpPress == true
		CheckEqual(specialStage.emeralds, 0b01111111)
		temp0 = checkResult
		CheckGreater(player.rings, 49)
		temp0 &= checkResult
		CheckNotEqual(PlayerObject_SuperState, SUPERSTATE_SUPER)
		temp0 &= checkResult

		if temp0 == true
			currentPlayer = object.entityPos
			CallFunction(PlayerObject_SuperTransform)
		else
			object.speed = 0x40000
			if object.yvel < 0
				object.yvel = 0
			end if

			if object.direction == FLIP_NONE
				object.state = PlayerObject_KnuxGlideRight
				object.xvel = 0x40000
				player.timer = 0
			else
				object.state = PlayerObject_KnuxGlideLeft
				object.xvel = -0x40000
				player.timer = 256
			end if

			object.animation = ANI_GLIDING
			object.frame = 2
		end if
	end if
end function


function PlayerObject_HandleGround
	if object.animation != ANI_SKIDDING
		temp7 = true
	else
		temp7 = false
	end if

	CallFunction(PlayerObject_HandleMovement)
	if object.gravity == GRAVITY_AIR
		object.state = PlayerObject_HandleAir
		CallFunction(PlayerObject_HandleAirMovement)
	else
		CallFunction(PlayerObject_ResetOnFloor)
		if object.speed == 0
			if object.collisionMode == CMODE_FLOOR
				switch player.character
				case PlayerName[SONIC]
					if PlayerObject_SuperState == SUPERSTATE_SUPER
						object.animation = ANI_STOPPED
						player.timer = 0
						if object.floorSensorC == false
							if object.floorSensorR == false
								object.animation = ANI_FLAILING1
								object.direction = FLIP_NONE
							end if

							if object.floorSensorL == false
								object.animation = ANI_FLAILING1
								object.direction = FLIP_X
							end if
						end if
					else
						if player.timer < 240
							object.animation = ANI_STOPPED
							player.timer++
						else
							object.animation = ANI_WAITING
							player.timer++
							if player.timer == 0x4B0
								player.timer = 0
								object.state = PlayerObject_HandleBored2
							end if
						end if

						if object.direction == FLIP_NONE
							if object.floorSensorR == false
								if object.floorSensorC == false
									player.timer = 0
									if object.floorSensorLC == false
										object.animation = ANI_FLAILING3
									else
										object.animation = ANI_FLAILING1
									end if
								end if
							else
								if object.floorSensorL == false
									if object.floorSensorC == false
										player.timer = 0
										object.animation = ANI_FLAILING2
									end if
								end if
							end if
						else
							if object.floorSensorL == false
								if object.floorSensorC == false
									player.timer = 0
									if object.floorSensorRC == false
										object.animation = ANI_FLAILING3
									else
										object.animation = ANI_FLAILING1
									end if
								end if
							else
								if object.floorSensorR == false
									if object.floorSensorC == false
										player.timer = 0
										object.animation = ANI_FLAILING2
									end if
								end if
							end if
						end if
					end if
					break

				case PlayerName[TAILS]
					if player.timer < 240
						object.animation = ANI_STOPPED
						player.timer++
					else
						object.animation = ANI_WAITING
					end if

					if object.floorSensorC == false
						if object.floorSensorR == false
							player.timer = 0
							object.animation = ANI_FLAILING1
							object.direction = FLIP_NONE
						end if
						if object.floorSensorL == false
							player.timer = 0
							object.animation = ANI_FLAILING1
							object.direction = FLIP_X
						end if
					end if
					break

				case PlayerName[KNUCKLES]
					if player.timer < 240
						object.animation = ANI_STOPPED
						player.timer++
					else
						object.animation = ANI_WAITING
						player.timer++
						if player.timer == 834
							player.timer = 0
							object.animation = ANI_STOPPED
						end if
					end if

					if object.floorSensorC == false
						if object.floorSensorR == false
							player.timer = 0
							object.animation = ANI_FLAILING1
							if object.direction == FLIP_X
								object.prevAnimation = ANI_FLAILING1
								object.frame = 4
								object.animationTimer = 0
								object.animationSpeed = 0
							end if
							object.direction = FLIP_NONE
						end if

						if object.floorSensorL == false
							player.timer = 0
							object.animation = ANI_FLAILING1
							if object.direction == FLIP_NONE
								object.prevAnimation = ANI_FLAILING1
								object.frame = 4
								object.animationTimer = 0
								object.animationSpeed = 0
							end if
							object.direction = FLIP_X
						end if
					end if
					break
				end switch
			end if
		else
			player.timer = 0
			if object.speed > 0
				if object.speed < 0x5F5C2
					object.animation = ANI_WALKING
					CallFunction(PlayerObject_WalkAnimSpd)
				else
					if object.speed > 0x9FFFF
						object.animation = ANI_PEELOUT
					else
						object.animation = ANI_RUNNING
					end if
					CallFunction(PlayerObject_RunAnimSpd)
				end if
			else
				if object.speed > -0x5F5C2
					object.animation = ANI_WALKING
					CallFunction(PlayerObject_WalkAnimSpd)
				else
					if object.speed < -0x9FFFF
						object.animation = ANI_PEELOUT
					else
						object.animation = ANI_RUNNING
					end if
					CallFunction(PlayerObject_RunAnimSpd)
				end if
			end if
		end if

		if player.skidding > 0
			if temp7 == true
				PlaySfx(SfxName[Skidding], false)
			end if
			object.animation = ANI_SKIDDING
			object.animationSpeed = 0
			player.skidding--
			if ringTimer == 0
				CreateTempObject(TypeName[Dust Puff], 0, object.xpos, object.ypos)
				object[tempObjectPos].iypos += object.collisionBottom
				object[tempObjectPos].drawOrder = player.sortedDrawOrder
			end if

			if object.speed > 0
				object.direction = FLIP_NONE
			else
				object.direction = FLIP_X
			end if
		end if

		if object.collisionMode == CMODE_FLOOR
			if object.pushing == 2
				object.animation = ANI_PUSHING
				object.animationSpeed = 0
			end if
		end if

		if object.jumpPress == true
			CallFunction(PlayerObject_StartJump)
		else
			if object.up == true
				if object.speed == 0
					if object.animation != ANI_FLAILING1
						if object.animation != ANI_FLAILING2
							object.state = PlayerObject_LookingUp
							player.timer = 0
						else
							object.up = false
							object.down = false
						end if
					else
						object.up = false
						object.down = false
					end if
				end if
			end if

			if object.down == true
				if object.speed == 0
					if object.animation != ANI_FLAILING1
						if object.animation != ANI_FLAILING2
							object.state = PlayerObject_Crouching
							player.timer = 0
						else
							object.up = false
							object.down = false
						end if
					else
						object.up = false
						object.down = false
					end if
				else
					if object.left == false
						if object.right == false
							if object.speed > 0
								if object.speed > 0x8800
									object.state = PlayerObject_HandleRolling
									object.animation = ANI_JUMPING
									if object.prevAnimation != ANI_JUMPING
										object.iypos -= player.jumpOffset
									end if

									player.abilityTimer = 0x400
									PlaySfx(SfxName[Rolling], false)
								end if
							else
								if object.speed < -0x8800
									object.state = PlayerObject_HandleRolling
									object.animation = ANI_JUMPING
									if object.prevAnimation != ANI_JUMPING
										object.iypos -= player.jumpOffset
									end if

									player.abilityTimer = 0x400
									PlaySfx(SfxName[Rolling], false)
								end if
							end if
						end if
					end if
				end if
			end if
		end if
	end if
end function


function PlayerObject_HandleBored2
	if object.gravity == GRAVITY_AIR
		object.state = PlayerObject_HandleAir
		CallFunction(PlayerObject_HandleAirMovement)
	else
		CallFunction(PlayerObject_ResetOnFloor)
		if object.animation == ANI_CONTINUE_UP
			if object.frame == 1
				object.state = PlayerObject_HandleGround
			end if
		else
			object.animation = ANI_BORED
		end if

		if object.jumpPress == true
			CallFunction(PlayerObject_StartJump)
		else
			if object.up == true
				object.animation = ANI_CONTINUE_UP
			end if

			if object.down == true
				object.animation = ANI_CONTINUE_UP
			end if

			if object.left == true
				object.animation = ANI_CONTINUE_UP
			end if

			if object.right == true
				object.animation = ANI_CONTINUE_UP
			end if
		end if
	end if
end function


function PlayerObject_HandleAir
	CallFunction(PlayerObject_AirAcceleration)
	if object.gravity == GRAVITY_AIR
		CallFunction(PlayerObject_HandleAirMovement)

		if object.yvel > 0x20000
			if object.animation == ANI_FLAILING1
				object.animation = ANI_WALKING
			end if

			if object.animation == ANI_FLAILING2
				object.animation = ANI_WALKING
			end if
		end if

		if object.animation == ANI_BOUNCING
			if object.yvel >= 0
				if player.animationReserve == ANI_STOPPED
					player.animationReserve = ANI_WALKING
				end if
				object.animation = player.animationReserve
			end if
		end if

		if object.animation == ANI_SKIDDING
			if player.skidding > 0
				player.skidding--
			else
				object.animation = ANI_WALKING
				object.prevAnimation = ANI_WALKING
				object.frame = 0
				object.animationSpeed = 40
			end if
		end if

		if object.animation == ANI_TWIRL
			if object.animationSpeed == 40
				if object.frame >= 12
					object.animation = ANI_WALKING
					object.prevAnimation = ANI_WALKING
					object.frame = 0
				end if
			else
				if object.frame >= 24
					object.animation = ANI_WALKING
					object.prevAnimation = ANI_WALKING
					object.frame = 0
					object.animationSpeed = 40
				end if
			end if
		end if

		if object.animation == ANI_HURT
			if object.yvel >= 0
				if player.animationReserve == ANI_STOPPED
					player.animationReserve = ANI_WALKING
				end if
				object.animation = player.animationReserve
			end if
		end if

		if object.animation == ANI_JUMPING
			if player.jumpAbilityState == 1
				if object.yvel >= player.jumpCap
					CallFunction(player.jumpAbility)
				end if
			end if
		end if
	else
		object.state = PlayerObject_HandleGround
		CallFunction(PlayerObject_ResetOnFloor)
		player.skidding = 0
	end if
end function


// Note that the actual control lock is set in PlayerObject_RollingJump, not here
function PlayerObject_AirCtrlLock
	CallFunction(PlayerObject_AirAcceleration)

	if object.gravity == GRAVITY_AIR
		CallFunction(PlayerObject_HandleAirMovement)
	else
		object.state = PlayerObject_TubeSwitch
		CallFunction(PlayerObject_ResetOnFloor)
		player.skidding = 0
	end if

	object.animation = ANI_JUMPING
end function


function PlayerObject_HandleRolling
	CallFunction(PlayerObject_HandleRollingDecel)

	if object.gravity == GRAVITY_AIR
		object.state = PlayerObject_HandleAir
		player.timer = 0
		CallFunction(PlayerObject_HandleAirMovement)
	else
		CallFunction(PlayerObject_RollAnimSpd)
		object.animationSpeed = player.customRollAnimSpeed
		CallFunction(PlayerObject_ResetOnFloor)
		if object.jumpPress == true
			CallFunction(PlayerObject_StartJump)
		end if
	end if
end function


function PlayerObject_RollingJump
	object.left = false
	object.right = false
	CallFunction(PlayerObject_AirAcceleration)
	
	if object.gravity == GRAVITY_AIR
		if object.animation == ANI_JUMPING
			if player.jumpAbilityState == 1
				if object.yvel >= player.jumpCap
					CallFunction(player.jumpAbility)
				end if
			end if
		end if

		CallFunction(PlayerObject_HandleAirMovement)
	else
		object.state = PlayerObject_HandleGround
		CallFunction(PlayerObject_ResetOnFloor)
		player.skidding = 0
	end if
end function


function PlayerObject_LookingUp
	if object.up == false
		object.state = PlayerObject_HandleGround
		player.timer = 0
	else
		if player.timer < 60
			player.timer++
		else
			temp0 = object.ypos
			temp0 >>= 16
			temp0 -= screen.cameraY
			temp0 -= 112
			if object.lookPosY > temp0
				object.lookPosY -= 2
			end if
		end if

		object.animation = ANI_LOOKINGUP
		if object.gravity == GRAVITY_AIR
			object.state = PlayerObject_HandleAir
			player.timer = 0
		else
			if object.jumpPress == true
				CallFunction(PlayerObject_StartJump)
			end if
		end if
	end if
end function


function PlayerObject_Crouching
	if object.down == false
		object.state = PlayerObject_HandleGround
		player.timer = 0
	else
		if player.timer < 60
			player.timer++
		else
			temp0 = object.ypos
			temp0 >>= 16
			temp0 -= screen.cameraY
			temp0 += 96
			if object.lookPosY < temp0
				object.lookPosY += 2
			end if
		end if

		object.animation = ANI_LOOKINGDOWN
		if object.gravity == GRAVITY_AIR
			object.state = PlayerObject_HandleAir
			player.timer = 0
		else
			if object.jumpPress == true
				CallFunction(player.spindashFunction)
			end if
		end if
	end if
end function


function PlayerObject_HandleSpindash
	if object.gravity == GRAVITY_AIR
		object.state = PlayerObject_HandleAir
		object.speed = 0
	end if

	if object.jumpPress == true
		if player.abilityTimer < 0x90000
			player.abilityTimer += 0x20000
		else
			player.abilityTimer = 0x80000
		end if

		object.frame = 0
		PlaySfx(SfxName[Charge], false)
	else
		temp0 = player.abilityTimer
		temp0 >>= 5
		player.abilityTimer -= temp0
	end if

	if object.down == false
		player.timer = 0
		object.state = PlayerObject_HandleRolling
		object.animation = ANI_JUMPING
		object.iypos -= player.jumpOffset
		if object.entityPos == screen.cameraTarget
			player.scrollDelay = 15
			screen.cameraStyle = 4
		end if

		temp0 = player.abilityTimer
		temp0 >>= 17
		temp0 <<= 16
		if PlayerObject_SuperState == SUPERSTATE_SUPER
			temp0 += 0xB0000
		else
			temp0 += 0x80000
		end if

		if object.direction == FLIP_NONE
			object.speed = temp0
		else
			object.speed = temp0
			FlipSign(object.speed)
		end if

		StopSfx(SfxName[Charge])
		PlaySfx(SfxName[Release], false)
		CallFunction(PlayerObject_ResetOnFloor)
	end if
end function


function PlayerObject_StartFlyCarry
	if player.flyCarryTimer != 0
		player.flyCarryTimer--
	end if

	temp0 = object.xpos
	temp1 = object.ypos
	temp1 += 0x1F0000
	if player[0].animation == ANI_JUMPING
		temp1 += 0x50000
	end if

	temp0 -= player[0].xpos
	temp1 -= player[0].ypos
	if player[0].state != PlayerObject_HandleFlyCarry
		CheckEqual(player[0].gravity, GRAVITY_GROUND)
		temp2 = checkResult
		CheckGreater(object.yvel, 0)
		temp2 &= checkResult

		if temp2 == false
			CheckEqual(player[0].state, PlayerObject_HandleGround)
			temp2 = checkResult
			CheckEqual(player[0].state, PlayerObject_HandleRolling)
			temp2 |= checkResult
			CheckEqual(player[0].state, PlayerObject_HandleAir)
			temp2 |= checkResult
			CheckEqual(player[0].state, PlayerObject_RollingJump)
			temp2 |= checkResult
			CheckEqual(player[0].state, PlayerObject_LookingUp)
			temp2 |= checkResult
			CheckEqual(player[0].state, PlayerObject_Crouching)
			temp2 |= checkResult

			if temp2 != false
				temp2 = temp0
				Abs(temp2)
				temp3 = temp1
				Abs(temp3)
				if temp2 <= 0x80000
					if temp3 <= 0x80000
						if player.flyCarryTimer == 0
							if player[0].down == false
								player[0].animation = ANI_HANGING
								player[0].state = PlayerObject_HandleFlyCarry
								player[0].xpos += temp0
								player[0].ypos += temp1
								PlaySfx(SfxName[Catch], false)
							end if
						end if
					end if
				end if
			end if
		end if
	end if

	if player[0].state == PlayerObject_HandleFlyCarry
		temp2 = object.xpos
		temp3 = object.ypos
		temp6 = object.xvel
		temp7 = object.yvel
		ProcessObjectMovement()

		PlayerObject_flyCarryBuddyXPos = object.xpos
		PlayerObject_flyCarryBuddyYPos = object.ypos
		temp4 = object.xpos
		temp4 &= 0xFFFF0000
		temp5 = object.ypos
		temp5 &= 0xFFFF0000
		temp5 += 0x1F0000
		object.xpos = temp2
		object.ypos = temp3
		object.xvel = temp6
		object.yvel = temp7
		stage.entityPos = 0
		temp0 = object.xpos
		temp0 &= 0xFFFF0000
		temp1 = object.ypos
		temp1 &= 0xFFFF0000
		object.xvel = temp4
		object.yvel = temp5
		object.xvel -= temp0
		object.yvel -= temp1
		ProcessObjectMovement()

		stage.entityPos = 1
		player[0].collisionPlane = object.collisionPlane
		player[0].speed = object.speed
		player[0].direction = object.direction
		PlayerObject_flyCarryLeaderXPos = player[0].xpos
		PlayerObject_flyCarryLeaderYPos = player[0].ypos
		temp2 = player[0].xpos
		temp2 &= 0xFFFF0000
		temp3 = player[0].ypos
		temp3 &= 0xFFFF0000
		CheckNotEqual(temp4, temp2)
		temp6 = checkResult
		CheckNotEqual(temp5, temp3)
		temp6 |= checkResult
		if temp6 == true
			if player[0].gravity == GRAVITY_GROUND
				player[0].state = PlayerObject_HandleGround
			else
				player[0].state = PlayerObject_HandleAir
			end if

			player.flyCarryTimer = 30
		end if
	end if
end function


function PlayerObject_HandleFlyCarry
	if player[1].state != PlayerObject_HandleTailsFlight
		object.state = PlayerObject_HandleAir
	end if

	temp0 = player[1].xpos
	temp0 &= 0xFFFF0000
	temp2 = object.xpos
	temp2 &= 0xFFFF0000
	if object.xpos == PlayerObject_flyCarryLeaderXPos
		PlayerObject_flyCarryBuddyXPos &= 0xFFFF0000
		temp1 = temp0
		temp1 -= PlayerObject_flyCarryBuddyXPos
		temp2 += temp1
	end if

	if temp0 != temp2
		if object.gravity == GRAVITY_GROUND
			object.state = PlayerObject_HandleGround
		else
			object.state = PlayerObject_HandleAir
		end if
	end if

	if object.gravity == GRAVITY_GROUND
		if object.yvel >= 0
			object.state = PlayerObject_HandleGround
		end if
	end if

	if object.jumpPress != false
		if object.down != false
			if player.gravityStrength == 0x3800
				object.yvel = -0x40000
			else
				object.yvel = -0x20000
			end if
			object.state = PlayerObject_HandleAir
			object.animation = ANI_JUMPING
		end if
	end if

	if object.state == PlayerObject_HandleFlyCarry
		object.xvel = 0
		object.yvel = 0
		object.speed = 0
	else
		player[1].flyCarryTimer = 30
	end if
end function


function PlayerObject_HandleTailsFlight
	CallFunction(PlayerObject_AirAcceleration)
	if object.gravity == GRAVITY_AIR
		object.xvel = object.speed
		if object.yvel < -0x10000
			player.flightVelocity = 0x800
		else
			if object.yvel < 1
				if player.abilityTimer < 60
					player.abilityTimer++
				else
					player.flightVelocity = 0x800
				end if
			end if
		end if

		object.yvel += player.flightVelocity
		temp0 = stage.curYBoundary1
		temp0 += 16
		temp0 <<= 16

		if object.ypos < temp0
			if object.yvel < 0
				object.yvel = 0
			end if
		end if

		if options.vsMode == false
			CallFunction(PlayerObject_StartFlyCarry)
		end if

		if player.timer < 480
			if player.gravityStrength == 0x3800
				if player[0].state == PlayerObject_HandleFlyCarry
					if object.yvel < 0
						object.animation = ANI_FLY_LIFT_UP
						object.animationSpeed = 240
					else
						object.animation = ANI_FLY_LIFT_DOWN
						object.animationSpeed = 120
					end if
				else
					object.animation = ANI_FLYING
					if object.yvel < 0
						object.animationSpeed = 240
					else
						object.animationSpeed = 120
					end if
				end if
			else
				if player[0].state == PlayerObject_HandleFlyCarry
					object.animation = ANI_SWIM_LIFT
				else
					object.animation = ANI_SWIMMING
					
					if object.yvel < 0
						object.animationSpeed = 60
					else
						object.animationSpeed = 30
					end if
				end if
			end if

			player.timer++
			if player.timer == 480
				if player.gravityStrength == 0x3800
					if player[0].state == PlayerObject_HandleFlyCarry
						object.animation = ANI_FLY_LIFT_TIRED
					else
						object.animation = ANI_FLYINGTIRED
					end if
					object.animationSpeed = 120

					StopSfx(SfxName[Flying])
					PlaySfx(SfxName[Tired], true)
				else
					if player[0].state == PlayerObject_HandleFlyCarry
						object.animation = ANI_SWIM_LIFT
					else
						object.animation = ANI_SWIMMINGTIRED
					end if
				end if
			else
				if object.jumpPress == true
					CheckNotEqual(player.gravityStrength, 0x3800)
					temp0 = checkResult
					CheckEqual(player[0].state, PlayerObject_HandleFlyCarry)
					temp0 &= checkResult

					if temp0 == false
						player.flightVelocity = -0x2000
						player.abilityTimer = 0
					end if
				end if
			end if
		else
			if player.gravityStrength == 0x3800
				if player[0].state == PlayerObject_HandleFlyCarry
					object.animation = ANI_FLY_LIFT_TIRED
				else
					object.animation = ANI_FLYINGTIRED
				end if
			else
				if player[0].state == PlayerObject_HandleFlyCarry
					object.animation = ANI_SWIM_LIFT
				else
					object.animation = ANI_SWIMMINGTIRED
				end if
			end if
		end if
	else
		object.animation = ANI_WALKING
		object.state = PlayerObject_HandleGround
		CallFunction(PlayerObject_ResetOnFloor)
	end if
end function


function PlayerObject_KnuxGlideLeft
	if object.gravity == GRAVITY_AIR
		if object.jumpHold == true
			if player.timer == 256
				if object.speed < 0x180000
					object.speed += 0x400
				end if
			else
				if object.speed < 0x40000
					object.speed += 0x1000
				end if
			end if

			if object.yvel > 0x8000
				object.yvel -= 0x2000
			else
				object.yvel += 0x2000
			end if

			if player.timer < 256
				player.timer += 4
			end if

			if player.timer < 170
				if player.timer > 86
					object.frame = 0
				else
					if player.timer > 44
						object.frame = 1
					else
						object.frame = 2
					end if
				end if
			else
				if player.timer < 212
					object.frame = 1
				else
					object.frame = 2
				end if
			end if

			temp7 = object.xpos
			if player.timer < 128
				object.direction = FLIP_NONE
				temp0 = false
				temp1 = false
			else
				object.direction = FLIP_X
				object.xpos = temp7
				object.xpos += object.xvel
				object.ypos = object.ypos
				ObjectTileCollision(CSIDE_RWALL, -12, -2, object.collisionPlane)

				temp0 = checkResult
				temp2 = object.xpos
				object.xpos = temp7
				object.xpos += object.xvel
				ObjectTileCollision(CSIDE_RWALL, -12, 11, object.collisionPlane)

				temp1 = checkResult
				temp3 = object.xpos
			end if

			Cos(object.xvel, player.timer)
			object.xvel *= object.speed
			object.xvel >>= 9

			if object.right == true
				object.state = PlayerObject_KnuxGlideRight
			end if

			object.xpos = temp7
			checkResult = temp0
			checkResult &= temp1
			if checkResult == true
				if temp2 == temp3
					object.state = PlayerObject_KnuxWallClimb
					object.speed = 0
					object.xvel = 0
					object.yvel = 0
					player.timer = 0
					PlaySfx(SfxName[Catch], false)
				else
					player.timer = 0
					object.xvel >>= 2
					object.speed = object.xvel
					object.animation = ANI_GLIDING_DROP
					object.state = PlayerObject_KnuxGlideDrop
				end if
			else
				if temp0 == true
					player.timer = 0
					object.xvel >>= 2
					object.speed = object.xvel
					object.animation = ANI_GLIDING_DROP
					object.state = PlayerObject_KnuxGlideDrop
				end if
			end if
		else
			player.timer = 0
			object.xvel >>= 2
			object.speed = object.xvel
			object.animation = ANI_GLIDING_DROP
			object.state = PlayerObject_KnuxGlideDrop
		end if
	else
		if object.collisionMode == CMODE_FLOOR
			player.timer = 0
			object.state = PlayerObject_KnuxGlideSlide
			object.animation = ANI_GLIDING_STOP
			object.speed = object.xvel
		else
			object.state = PlayerObject_HandleGround
			CallFunction(PlayerObject_ResetOnFloor)
			player.skidding = 0
		end if
	end if

	temp0 = stage.curYBoundary1
	temp0 += 16
	temp0 <<= 16
	if object.ypos < temp0
		object.xvel = 0
		object.speed = object.xvel
	end if
end function


function PlayerObject_KnuxGlideRight
	if object.gravity == GRAVITY_AIR
		if object.jumpHold == true
			if player.timer == 0
				if object.speed < 0x180000
					object.speed += 0x400
				end if
			else
				if object.speed < 0x40000
					object.speed += 0x1000
				end if
			end if

			if object.yvel > 0x8000
				object.yvel -= 0x2000
			else
				object.yvel += 0x2000
			end if

			if player.timer > 0
				player.timer -= 4
			end if

			if player.timer < 170
				if player.timer > 86
					object.frame = 0
				else
					if player.timer > 44
						object.frame = 1
					else
						object.frame = 2
					end if
				end if
			else
				if player.timer < 212
					object.frame = 1
				else
					object.frame = 2
				end if
			end if

			temp7 = object.xpos
			if player.timer < 128
				object.direction = FLIP_NONE
				object.xpos = temp7
				object.xpos += object.xvel
				object.ypos = object.ypos
				ObjectTileCollision(CSIDE_LWALL, 12, -2, object.collisionPlane)

				temp0 = checkResult
				temp2 = object.xpos
				object.xpos = temp7
				object.xpos += object.xvel
				ObjectTileCollision(CSIDE_LWALL, 12, 11, object.collisionPlane)

				temp1 = checkResult
				temp3 = object.xpos
			else
				object.direction = FLIP_X
				temp0 = false
				temp1 = false
			end if

			Cos(object.xvel, player.timer)
			object.xvel *= object.speed
			object.xvel >>= 9
			if object.left == true
				object.state = PlayerObject_KnuxGlideLeft
			end if

			object.xpos = temp7
			checkResult = temp0
			checkResult &= temp1
			if checkResult == true
				temp2 >>= 1
				temp3 >>= 1
				if temp2 == temp3
					object.state = PlayerObject_KnuxWallClimb
					object.speed = 0
					object.xvel = 0
					object.yvel = 0
					player.timer = 0
					PlaySfx(SfxName[Catch], false)
				else
					player.timer = 0
					object.xvel >>= 2
					object.speed = object.xvel
					object.animation = ANI_GLIDING_DROP
					object.state = PlayerObject_KnuxGlideDrop
				end if
			else
				if temp0 == true
					object.speed = 0
					player.timer = 0
					object.xvel >>= 2
					object.speed = object.xvel
					object.animation = ANI_GLIDING_DROP
					object.state = PlayerObject_KnuxGlideDrop
				end if
			end if
		else
			player.timer = 0
			object.xvel >>= 2
			object.speed = object.xvel
			object.animation = ANI_GLIDING_DROP
			object.state = PlayerObject_KnuxGlideDrop
		end if
	else
		if object.collisionMode == CMODE_FLOOR
			player.timer = 0
			object.state = PlayerObject_KnuxGlideSlide
			object.animation = ANI_GLIDING_STOP
			object.speed = object.xvel
		else
			object.state = PlayerObject_HandleGround
			CallFunction(PlayerObject_ResetOnFloor)
			player.skidding = 0
		end if
	end if

	temp0 = stage.curYBoundary1
	temp0 += 16
	temp0 <<= 16
	if object.ypos < temp0
		object.xvel = 0
		object.speed = object.xvel
	end if
end function


function PlayerObject_KnuxGlideDrop
	if object.gravity == GRAVITY_AIR
		CallFunction(PlayerObject_AirAcceleration)
		CallFunction(PlayerObject_HandleAirMovement)
	else
		if player.timer == 0
			PlaySfx(SfxName[Landing], false)
		end if

		object.scrollTracking = 0
		object.speed = 0
		object.xvel = 0
		object.animation = ANI_LOOKINGDOWN
		object.prevAnimation = ANI_LOOKINGDOWN
		object.frame = 2

		if player.timer < 16
			player.timer++
		else
			object.state = PlayerObject_HandleGround
			CallFunction(PlayerObject_ResetOnFloor)
			player.skidding = 0
		end if
	end if
end function


function PlayerObject_KnuxGlideSlide
	if object.gravity == GRAVITY_GROUND
		if object.speed == 0
			object.scrollTracking = false
			object.frame = 1
			if player.timer < 16
				player.timer++
			else
				object.state = PlayerObject_HandleGround
				CallFunction(PlayerObject_ResetOnFloor)
				player.skidding = 0
			end if
		else
			if ringTimer == 0
				CreateTempObject(TypeName[Dust Puff], 0, object.xpos, object.ypos)
				object[tempObjectPos].iypos += object.collisionBottom
				object[tempObjectPos].drawOrder = player.sortedDrawOrder

				if player.timer == 0
					PlaySfx(SfxName[Sliding], false)
					player.timer = 1
				else
					player.timer = 0
				end if
			end if

			object.frame = 0
			if object.speed > 0
				object.speed -= 0x2000
				if object.speed < 0
					object.speed = 0
					player.timer = 0
				end if
			else
				object.speed += 0x2000
				if object.speed > 0
					object.speed = 0
					player.timer = 0
				end if
			end if

			if object.jumpHold == false
				object.speed = 0
				player.timer = 0
			end if
		end if

		object.xvel = object.speed
	else
		player.timer = 0
		object.animation = ANI_GLIDING_DROP
		object.state = PlayerObject_KnuxGlideDrop
	end if
end function


function PlayerObject_KnuxWallClimb
	if object.gravity == GRAVITY_AIR
		object.animation = ANI_CLIMBING
		if object.up == true
			if PlayerObject_SuperState == SUPERSTATE_SUPER
				object.yvel = -0x20000
			else
				object.yvel = -0x10000
			end if
			temp0 = object.collisionTop
			temp0 *= -0x10000

			if object.ypos < temp0
				object.ypos = temp0
			end if

			player.timer++
			if player.timer == 4
				player.timer = 0
				object.frame++
				object.frame %= 6
			end if
		else
			if object.down == true
				if PlayerObject_SuperState == SUPERSTATE_SUPER
					object.yvel = 0x20000
				else
					object.yvel = 0x10000
				end if

				player.timer++
				if player.timer == 4
					player.timer = 0
					if object.frame < 1
						object.frame += 6
					end if

					object.frame--
				end if
			else
				object.yvel = 0
			end if
		end if

		if object.jumpPress == true
			object.animation = ANI_JUMPING
			object.state = PlayerObject_HandleAir
			player.timer = 0
			PlaySfx(SfxName[Jump], false)

			if object.direction == FLIP_X
				object.xvel = 0x40000
				object.speed = 0x40000
				object.direction = FLIP_NONE
			else
				object.xvel = -0x40000
				object.speed = -0x40000
				object.direction = FLIP_X
			end if

			object.yvel = -0x40000
			if player.gravityStrength != 0x3800
				object.xvel >>= 1
				object.speed >>= 1
				object.yvel >>= 1
			end if
		else
			if object.direction == FLIP_NONE
				temp2 = object.xpos
				ObjectTileGrip(CSIDE_LWALL, 10, -10, object.collisionPlane)

				temp0 = checkResult
				temp3 = object.xpos
				object.xpos = temp2
				ObjectTileGrip(CSIDE_LWALL, 10, 11, object.collisionPlane)

				temp1 = checkResult
				if object.xpos > temp3
					object.xpos = temp3
				end if
			else
				temp2 = object.xpos
				ObjectTileGrip(CSIDE_RWALL, -10, -10, object.collisionPlane)

				temp0 = checkResult
				temp3 = object.xpos
				object.xpos = temp2
				ObjectTileGrip(CSIDE_RWALL, -10, 11, object.collisionPlane)

				temp1 = checkResult
				if object.xpos < temp3
					object.xpos = temp3
				end if
			end if

			if temp0 == false
				object.xpos = temp2
				object.animation = ANI_LEDGEPULLUP
				object.yvel = 0
				player.timer = 0
				object.state = PlayerObject_KnuxLedgePullUp
				object.tileCollisions = false

				if object.direction == FLIP_NONE
					object.xpos += 0x10000
				end if
			else
				if temp1 == false
					object.animation = ANI_GLIDING_DROP
					object.prevAnimation = ANI_GLIDING_DROP
					object.frame = 2
					player.timer = 0
					object.state = PlayerObject_KnuxGlideDrop
				end if
			end if
		end if
	else
		object.animation = ANI_WALKING
		object.state = PlayerObject_HandleGround
		CallFunction(PlayerObject_ResetOnFloor)
	end if
end function


function PlayerObject_KnuxLedgePullUp
	switch object.frame
	case 0
		if player.timer < 5
			ObjectTileGrip(CSIDE_FLOOR, 12, -9, object.collisionPlane)
			player.timer++
		else
			player.timer = 0
			object.frame++

			if object.direction == FLIP_NONE
				object.xpos += 0x90000
			else
				object.xpos -= 0x90000
			end if

			object.ypos -= 0xA0000
		end if
		break

	case 1
		if player.timer < 5
			player.timer++
		else
			player.timer = 0
			object.frame++

			if object.direction == FLIP_NONE
				object.xpos += 0x50000
			else
				object.xpos -= 0x50000
			end if

			object.ypos -= 0x20000
		end if
		break

	case 2
		if player.timer < 5
			player.timer++
		else
			player.timer = 0
			object.animation = ANI_STOPPED
			object.state = PlayerObject_HandleAir
			object.ypos -= 0xA0000
			object.tileCollisions = true
		end if
		break
	end switch
end function


function PlayerObject_Hurt
	if player.isSidekick == false
		arrayPos0 = object.entityPos
		arrayPos0 += playerCount
		if player.shield != SHIELD_NONE
			temp0 = 1
			ResetObjectEntity(arrayPos0, TypeName[Blank Object], 0, 0, 0)
			player.shield = SHIELD_NONE
			CheckEqual(options.spikeBehavior, 0)
			temp1 = checkResult
			CheckNotEqual(player.blinkTimer, 0)
			temp1 &= checkResult
			if temp1 == true
				PlaySfx(SfxName[Spike], false)
			else
				PlaySfx(SfxName[Hurt], false)
			end if
		else
			if player.rings == 0
				if player.blinkTimer != 0
					PlaySfx(SfxName[Spike], false)
				else
					PlaySfx(SfxName[Hurt], false)
				end if

				temp0 = 3
			else
				PlaySfx(SfxName[Lose Rings], false)
				temp0 = 2
			end if
		end if
	else
		temp0 = 1
		if player.blinkTimer != 0
			PlaySfx(SfxName[Spike], false)
		else
			PlaySfx(SfxName[Hurt], false)
		end if
	end if

	object.visible = true
	switch temp0
	default
	case 0
		break

	case 1
		object.state = PlayerObject_Knockback
		object.animation = ANI_HURT
		object.yvel = -0x40000
		object.gravity = GRAVITY_AIR
		object.scrollTracking = 1
		object.tileCollisions = 1
		player.blinkTimer = 120

		if player.gravityStrength == 0x1000
			object.speed >>= 1
			object.yvel >>= 1
		end if
		break

	case 2
		object.state = PlayerObject_Knockback
		object.animation = ANI_HURT
		object.yvel = -0x40000
		object.gravity = GRAVITY_AIR
		object.scrollTracking = true
		object.tileCollisions = true
		player.blinkTimer = 120
		if player.gravityStrength == 0x1000
			object.speed >>= 1
			object.yvel >>= 1
		end if

		temp0 = player.rings
		if temp0 > 16
			temp1 = temp0
			temp1 -= 16
			temp0 = 16
		else
			temp1 = 0
		end if

		if temp1 > 16
			temp1 = 16
		end if
		temp3 = temp1
		temp3 >>= 1
		temp3 <<= 5
		temp2 = 384
		temp2 -= temp3
		temp3 >>= 4
		if temp3 == temp1
			temp2 += 16
		else
			temp2 -= 16
		end if

		temp3 = 0
		while temp3 < temp1
			CreateTempObject(TypeName[Lose Ring], object.collisionPlane, object.xpos, object.ypos)
			Cos(object[tempObjectPos].xvel, temp2)
			Sin(object[tempObjectPos].yvel, temp2)
			object[tempObjectPos].xvel <<= 8
			object[tempObjectPos].yvel <<= 8
			object[tempObjectPos].animationSpeed = 256
			object[tempObjectPos].inkEffect = INK_ALPHA
			object[tempObjectPos].alpha = 256
			temp3++
			temp2 += 32
		loop
		temp3 = temp0
		temp3 >>= 1
		temp3 <<= 5
		temp2 = 384
		temp2 -= temp3
		temp3 >>= 4
		if temp3 == temp0
			temp2 += 16
		else
			temp2 -= 16
		end if

		temp3 = 0
		while temp3 < temp0
			CreateTempObject(TypeName[Lose Ring], object.collisionPlane, object.xpos, object.ypos)
			Cos(object[tempObjectPos].xvel, temp2)
			Sin(object[tempObjectPos].yvel, temp2)
			object[tempObjectPos].xvel <<= 9
			object[tempObjectPos].yvel <<= 9
			object[tempObjectPos].animationSpeed = 256
			object[tempObjectPos].inkEffect = INK_ALPHA
			object[tempObjectPos].alpha = 256
			temp3++
			temp2 += 32
		loop
		player.rings  = 0
		ringExtraLife = 100
		break

	case 3
		player.sortedDrawOrder = 6
		object.speed = 0
		object.yvel = -0x70000
		object.xvel = 0
		object.state = PlayerObject_Death
		object.animation = ANI_DYING
		object.tileCollisions = false
		object.interaction = false

		if object.entityPos == screen.cameraTarget
			object.priority = PRIORITY_ACTIVE_PAUSED
			if player[1].type == TypeName[Player 2 Object]
				player[1].priority = PRIORITY_ACTIVE_PAUSED
			end if

			screen.cameraEnabled = false

			if options.vsMode == false
				stage.state = STAGE_FROZEN
			end if
		end if

		if object[+playerCount].type == invincibilityType
			object[+playerCount].propertyValue = 3
		end if

		object[+playerCount].type = TypeName[Blank Object]
		break
	end switch
end function


function PlayerObject_Knockback
	if object.gravity == GRAVITY_AIR
		object.scrollTracking = true
		if player.gravityStrength == 0x3800
			object.yvel += 0x3000
		else
			object.yvel += 0xF00
		end if

		object.xvel = object.speed
	else
		object.state = PlayerObject_HandleGround
		object.speed = 0
		object.xvel = 0
		CallFunction(PlayerObject_ResetOnFloor)
	end if
end function


function PlayerObject_Death
	if player.entityPos == 0
		// If Player 1, then stop all Super activity
		if PlayerObject_SuperState == SUPERSTATE_SUPER
			PlayerObject_SuperState = SUPERSTATE_FADEOUT
		end if
	end if

	if player.controlMode != -1
		player.yvel 		= -0x70000
		player.controlMode 	= -1
	end if

	if player.blinkTimer != 0
		player.blinkTimer 	= 0
		player.visible 		= true
	end if

	player.yvel += 0x3800
	if player.animation != ANI_BORED
		player.animation = ANI_DYING
	end if

	if player.entityPos == screen.cameraTarget
		temp0 = screen.cameraY
		temp0 += 272
		temp0 <<= 16
		if player.ypos > temp0
			player.ypos = temp0
		end if
	end if

	if player.yvel > 0x100000
		if player.isSidekick == false
			// global variable "array" (yes, this is actually how its done)
			arrayPos0 = VarName[player.lives]
			arrayPos0 += player.entityPos
			global[arrayPos0]--

			if options.vsMode == false
				stage.timeEnabled = false

				object.type = TypeName[Death Event]
				deathEvent.drawOrder 	= 6
				deathEvent.leftTextPos 	= screen.xcenter
				deathEvent.leftTextPos -= 264
				deathEvent.rightTextPos = screen.xcenter
				deathEvent.rightTextPos += 200
				if options.gameMode == MODE_TIMEATTACK
					deathEvent.timer = 0
					deathEvent.state = DEATHEVENT_DEATH_TA
				else
					if global[arrayPos0] == true
						deathEvent.timer = -2880
						deathEvent.state = DEATHEVENT_GAMEOVER
						PlayMusic(TRACK_GAMEOVER)
						stage.pauseEnabled = false
					else
						deathEvent.timer = 0
						deathEvent.state = DEATHEVENT_DEATH
						if stage.timeOver == true
							deathEvent.timer = -2880
							deathEvent.state = DEATHEVENT_TIMEOVER
							PlayMusic(TRACK_GAMEOVER)
							stage.pauseEnabled = false
						end if
					end if
				end if
			else
				if global[arrayPos0] == 0 // player.lives
					player.type = TypeName[Death Event]
					deathEvent.state = DEATHEVENT_GAMEOVER
				end if

				if stage.timeOver == true
					player.type = TypeName[Death Event]
					deathEvent.state = DEATHEVENT_TIMEOVER
				end if

				if object.type == TypeName[Death Event]
					deathEvent.drawOrder = 6
					deathEvent.leftTextPos = screen.xcenter
					deathEvent.leftTextPos -= 264
					deathEvent.rightTextPos = screen.xcenter
					deathEvent.rightTextPos += 200
					deathEvent.timer = -2880
					PlayMusic(TRACK_GAMEOVER)
					stage.pauseEnabled = false
				else
					object.state 		= PlayerObject_HandleAir
					player.rings 		= 0
					object.priority 	= PRIORITY_ACTIVE
					object.gravity 		= GRAVITY_AIR
					object.animation 	= ANI_HURT
					if object.entityPos == 0
						object.xpos = vs.restartX1
						object.ypos = vs.restartY1
					else
						object.xpos = vs.restartX2
						object.ypos = vs.restartY2
					end if
					object.direction 		= FLIP_NONE
					object.tileCollisions 	= true
					object.interaction 		= true
					object.visible 			= true
					player.controlMode 		= 0
					object.scrollTracking 	= true
					object.drawOrder 		= DRAWORDER_PLAYER
					player.sortedDrawOrder 	= 4
					object.collisionPlane 	= PATH_A

					if object.entityPos == screen.cameraTarget
						CreateTempObject(TypeName[VS Game], 0, object.xpos, object.ypos)
						vsGame[tempObjectPos].timer = 384
						vsGame[tempObjectPos].state = VSGAME_FADEOUT
						screen.cameraX = object.ixpos
						screen.cameraY = object.iypos
						screen.cameraEnabled = true
					end if
				end if
			end if
		end if
	end if
end function


function PlayerObject_Drown
	if object.entityPos == 0
		if PlayerObject_SuperState == SUPERSTATE_SUPER
			PlayerObject_SuperState = SUPERSTATE_FADEOUT
		end if
	end if

	player.controlMode 	= -1
	object.yvel 	   += player.gravityStrength
	object.animation 	= ANI_DROWNING
	if object.entityPos == screen.cameraTarget
		temp0   = screen.cameraY
		temp0  += 272
		temp0 <<= 16
		if object.ypos > temp0
			object.ypos = temp0
		end if
	end if

	if object.yvel > 0x80000
		if player.isSidekick == false
			// global variable "array" (yes, this is actually how its done)
			arrayPos0 = VarName[player.lives]
			arrayPos0 += object.entityPos
			if global[arrayPos0] > 0
				global[arrayPos0]--
			end if

			if options.vsMode == false
				stage.timeEnabled 		= false

				object.type 			= TypeName[Death Event]
				deathEvent.drawOrder 	= 6
				deathEvent.leftTextPos 	= screen.xcenter
				deathEvent.leftTextPos -= 264
				deathEvent.rightTextPos = screen.xcenter
				deathEvent.rightTextPos += 200
				if options.gameMode == MODE_TIMEATTACK
					deathEvent.timer = 0
					deathEvent.state = DEATHEVENT_DEATH_TA
				else
					if global[arrayPos0] == 0
						deathEvent.timer = -2880
						deathEvent.state = DEATHEVENT_GAMEOVER
						PlayMusic(TRACK_GAMEOVER)
						stage.pauseEnabled = false
					else
						deathEvent.timer = 0
						deathEvent.state = DEATHEVENT_DEATH
					end if
				end if
			else
				object.state 		= PlayerObject_HandleAir
				player.rings 		= 0
				object.priority 	= PRIORITY_ACTIVE
				object.gravity 		= GRAVITY_AIR
				object.animation 	= ANI_HURT
				if object.entityPos == 0
					object.xpos = vs.restartX1
					object.ypos = vs.restartY1
				else
					object.xpos = vs.restartX2
					object.ypos = vs.restartY2
				end if

				object.direction 		= FLIP_NONE
				object.tileCollisions 	= true
				object.interaction 		= true
				object.visible 			= true
				player.controlMode 		= 0
				object.scrollTracking 	= true
				object.drawOrder 		= DRAWORDER_PLAYER
				player.sortedDrawOrder 	= 4
				object.collisionPlane 	= PATH_A
				if object.entityPos == screen.cameraTarget
					CreateTempObject(TypeName[VS Game], 0, object.xpos, object.ypos)
					vsGame[tempObjectPos].timer = 384
					vsGame[tempObjectPos].state = VSGAME_FADEOUT
					screen.cameraX = object.ixpos
					screen.cameraY = object.iypos
					screen.cameraEnabled = true
				end if
			end if
		end if
	end if
end function


// Wacky Workbench hanging bar gimmick
// Unused leftover from CD
function PlayerObject_HangingBar
	if object.left == true
		object.direction = FLIP_X
		object.speed = -0x20000
		object.animationSpeed = 30
	else
		if object.right == true
			object.direction = FLIP_NONE
			object.speed = 0x20000
			object.animationSpeed = 30
		else
			object.speed = 0
			object.animationSpeed = 0
		end if
	end if

	temp1 = object.xpos
	temp1 >>= 16
	temp2 = object.ypos
	temp2 >>= 16
	temp2 += object.collisionTop
	Get16x16TileInfo(temp0, temp1, temp2, TILEINFO_ANGLEB)
	if temp0 != 3
		object.state = PlayerObject_HandleAir
		object.speed = 0
		object.animationSpeed = 0
		object.yvel = 0
	end if

	if object.jumpPress == true
		object.state = PlayerObject_HandleAir
		object.yvel = 0
		object.speed = 0
		object.animationSpeed = 0
		object.ypos += 0x40000
	end if
	object.xvel = object.speed
end function


function PlayerObject_TubeSwitch
	if object.gravity == GRAVITY_AIR
		object.state = PlayerObject_AirCtrlLock
		player.timer = 0
		CallFunction(PlayerObject_HandleAirMovement)
	else
		if object.speed > 0
			if object.collisionMode == CMODE_FLOOR
				if object.speed < 0x10000
					object.speed = 0x40000
				end if
			end if
		else
			if object.collisionMode == CMODE_FLOOR
				if object.speed > -0x10000
					object.speed = -0x40000
				end if
			end if
		end if

		if object.right == true
			if object.speed < 0
				object.speed += player.rollingDeceleration
			end if
		end if

		if object.left == true
			if object.speed > 0
				object.speed -= player.rollingDeceleration
			end if
		end if
		
		if object.speed > 0
			object.speed -= player.rollingFriction
			Sin256(temp0, object.angle)
			if temp0 > 0
				Sin256(temp0, object.angle)
				temp0 *= 0x5000
			else
				Sin256(temp0, object.angle)
				temp0 *= 0x1E00
			end if
			temp0 >>= 8

			object.speed += temp0
		else
			object.speed += player.rollingFriction
			Sin256(temp0, object.angle)
			if temp0 < 0
				Sin256(temp0, object.angle)
				temp0 *= 0x5000
			else
				Sin256(temp0, object.angle)
				temp0 *= 0x1E00
			end if
			temp0 >>= 8

			object.speed += temp0
		end if

		CallFunction(PlayerObject_RollAnimSpd)
		object.animationSpeed = player.customRollAnimSpeed
		CallFunction(PlayerObject_ResetOnFloor)
	end if
end function


function PlayerObject_Clinging
	player.gravity = GRAVITY_AIR
	if player.animation != ANI_CLINGING
		player.xvel = 0x80000
		player.speed = 0x80000
	else
		player.xvel = 0
		player.speed = 0
	end if

	if player.up == true
		player.ypos -= 0x10000
	else
		if player.down == true
			player.ypos += 0x10000
		end if
	end if

	player.yvel = 0
end function


function PlayerObject_Waterslide
	if player.gravity == GRAVITY_AIR
		player.state = PlayerObject_HandleAir
		player.angle = 0
		player.collisionMode = CMODE_FLOOR
		player.timer = 0
		CallFunction(PlayerObject_HandleAirMovement)
		player.animation = ANI_WATERSLIDE
	else
		if player.direction == FLIP_NONE
			player.speed = 0xA0000
		else
			player.speed = -0xA0000
		end if
		CallFunction(PlayerObject_RollAnimSpd)
		player.animation = ANI_WATERSLIDE

		CallFunction(PlayerObject_ResetOnFloor)
		if player.jumpPress == true
			CallFunction(PlayerObject_StartJump)
		end if
	end if
end function


function PlayerObject_HandleContRun
	if player.speed > 0x10000
		player.timer = 0
		if player.speed < 0x5F5C2
			player.animation = ANI_WALKING
			CallFunction(PlayerObject_WalkAnimSpd)
		else
			if player.speed > 0x9FFFF
				player.animation = ANI_PEELOUT
			else
				player.animation = ANI_RUNNING
			end if

			CallFunction(PlayerObject_RunAnimSpd)
		end if
	end if
end function


// ========================
// Events
// ========================

event ObjectMain
	if stage.debugMode == true
		CallFunction(PlayerObject_ProcessPlayer)
		CheckEqual(options.attractMode, false)
		temp0 = checkResult
		CheckEqual(inputPress.buttonB, true)
		temp0 &= checkResult

		if temp0 == true
			player.type = TypeName[Debug Mode]
			player.yvel = 0
			player.state = PlayerObject_Blank
			player.frame = 0
			player.rotation = 0
			player.interaction = 0
			player.drawOrder = 4
			player.priority = PRIORITY_ACTIVE
			player.blinkTimer = 0
			player.visible = true
			player.abilityTimer = 0
			player.drownTimer = 0
			player.drownLevel = 0
			player.frame = debugMode.currentSelection
			screen.cameraEnabled = true
			screen.cameraStyle = 0
			player.hitboxLeft 	= HITBOX_AUTO
			player.hitboxTop 	= HITBOX_AUTO
			player.hitboxRight 	= HITBOX_AUTO
			player.hitboxBottom = HITBOX_AUTO

			if stage.state == STAGE_FROZEN
				stage.state = STAGE_RUNNING
			end if

			if player[1].type == TypeName[Player 2 Object]
				player[1].priority = PRIORITY_ACTIVE
			end if

			if object[+playerCount].propertyValue == 3
				object[+playerCount].type = invincibilityType
				object[+playerCount].propertyValue = 0
			end if
		else
			if player.gravity == GRAVITY_GROUND
				player.jumpAbilityState = 0
			end if

			CallFunction(player.state)
			ProcessAnimation()

			if player.entityPos == screen.cameraTarget
				if player.animation == ANI_JUMPING
					screen.adjustCameraY = player.jumpOffset
				else
					if screen.adjustCameraY == player.jumpOffset
						screen.adjustCameraY = 0
						player.iypos += player.jumpOffset
					end if
				end if
			end if

			if player.collisionDisabled == false
				temp0 = player.prevGravity
				player.prevGravity = player.gravity
				ProcessObjectMovement()
				player.prevGravity ^= 1
				CheckEqual(player.gravity, GRAVITY_GROUND)
				player.prevGravity |= checkResult
				player.prevGravity ^= 1

				if temp0 == GRAVITY_AIR
					if player.prevGravity == GRAVITY_GROUND
						player.scoreBonus = 0
						if player.animation == ANI_JUMPING
							if player.down == false
								if player.state != PlayerObject_BubbleBounce
									if player.state != PlayerObject_HandleRolling
										if player.state != PlayerObject_TubeSwitch
											player.animation = ANI_WALKING
											if player.entityPos == screen.cameraTarget
												screen.adjustCameraY = 0
											end if

											player.iypos += player.jumpOffset
										end if
									end if
								end if
							end if
						end if
					end if
				end if
			else
				player.collisionDisabled = false
			end if
		end if
	else
		CallFunction(PlayerObject_ProcessPlayer)

		if player.gravity == GRAVITY_GROUND
			player.jumpAbilityState = 0
		end if

		CallFunction(player.state)
		ProcessAnimation()

		if player.entityPos == screen.cameraTarget
			if player.animation == ANI_JUMPING
				screen.adjustCameraY = player.jumpOffset
			else
				if screen.adjustCameraY == player.jumpOffset
					screen.adjustCameraY = 0
					player.iypos += player.jumpOffset
				end if
			end if
		end if

		if player.collisionDisabled == false
			temp0 = player.prevGravity
			player.prevGravity = player.gravity
			ProcessObjectMovement()
			player.prevGravity ^= 1
			CheckEqual(player.gravity, GRAVITY_GROUND)
			player.prevGravity |= checkResult
			player.prevGravity ^= 1

			if temp0 == GRAVITY_GROUND
				if player.prevGravity == GRAVITY_GROUND
					player.scoreBonus = 0
					if player.animation == ANI_JUMPING
						if player.down == false
							if player.state != PlayerObject_BubbleBounce
								if player.state != PlayerObject_HandleRolling
									if player.state != PlayerObject_TubeSwitch
										player.animation = ANI_WALKING
										if player.entityPos == screen.cameraTarget
											screen.adjustCameraY = 0
										end if

										player.iypos += player.jumpOffset
									end if
								end if
							end if
						end if
					end if
				end if
			end if
		else
			player.collisionDisabled = false
		end if
	end if

	CallFunction(PlayerObject_ProcessSuperState)
end event


event ObjectDraw
	if player.animation != player.prevAnimation
		// If the player's animation is different than the one they had last frame,
		// Reset all the other animation values too
		player.prevAnimation = player.animation
		player.frame = 0
		player.animationTimer = 0
		player.animationSpeed = 0
	end if

	DrawObjectAnimation()
end event


event ObjectStartup
	playerCount = 0

	foreach (TypeName[Player Object], arrayPos0, ALL_ENTITIES)
		screen.cameraEnabled = true
		screen.cameraStyle = 0
		screen.cameraTarget = 0

		currentPlayer = 0
		if stage.playerListPos >= PlayerName[SONIC AND TAILS]
			stage.playerListPos = PlayerName[SONIC]
			stage.player2Enabled = true
		end if

		ResetObjectEntity(0, TypeName[Player Object], 0, player[arrayPos0].xpos, player[arrayPos0].ypos)
		screen.cameraX = player[0].ixpos
		screen.cameraY = player[0].iypos

		player[0].groupID 				= GROUP_PLAYERS
		player[0].state 				= PlayerObject_HandleAir
		player[0].priority 				= PRIORITY_ACTIVE
		player[0].drawOrder 			= DRAWORDER_PLAYER
		player[0].sortedDrawOrder 		= 4
		player[0].rollingDeceleration 	= 0x2000
		player[0].spindashFunction 		= PlayerObject_StartSpindash
		player[0].hitboxLeft 			= HITBOX_AUTO
		player[0].hitboxTop 			= HITBOX_AUTO
		player[0].hitboxRight 			= HITBOX_AUTO
		player[0].hitboxBottom 			= HITBOX_AUTO

		// Reset things for Super forms
		PlayerObject_SuperState 		= SUPERSTATE_NONE
		PlayerObject_SuperRingLossTimer = 0
		PlayerObject_SuperBlendClr 		= 0
		PlayerObject_SuperBlendTimer 	= 0

		switch stage.playerListPos
		case PlayerName[SONIC]
			LoadAnimation("SuperSonic.ani")
			LoadAnimation("Sonic.ani")
			CallFunction(PlayerObject_ProcessSuperPalS)
			player[0].character 	= PlayerName[SONIC]
			player[0].jumpOffset 	= -5
			player[0].jumpAbility 	= PlayerObject_JumpAbility_Sonic
			ANI_PEELOUT 			= ANI_RUNNING
			break

		case PlayerName[TAILS]
			player[0].type 		= TypeName[Tails Object]
			player[0].character = PlayerName[TAILS]
			CallFunction(PlayerObject_ProcessSuperPalT)
			LoadAnimation("Tails.ani")
			player[0].jumpOffset = -1

			if options.vsMode == true
				// Tails can always fly in 2P VS
				options.tailsFlight = true
			end if

			if options.tailsFlight == true
				player[0].jumpAbility = PlayerObject_JumpAbility_Tails
			else
				player[0].jumpAbility = PlayerObject_Blank
			end if

			stage.player2Enabled = false
			break

		case PlayerName[KNUCKLES]
			LoadAnimation("Knuckles.ani")
			CallFunction(PlayerObject_ProcessSuperPalK)
			player[0].character 	= PlayerName[KNUCKLES]
			player[0].jumpOffset 	= -5
			player[0].jumpAbility 	= PlayerObject_JumpAbility_Knux
			ANI_PEELOUT 			= ANI_RUNNING

			if options.saveSlot > 0
				stage.player2Enabled = false
			end if
			break
		end switch

		if stage.player2Enabled == true
			playerCount = 2
		else
			playerCount = 1
		end if

		currentPlayer = 0
		CallFunction(PlayerObject_UpdatePhysicsState)
		ResetObjectEntity(arrayPos0, TypeName[Blank Object], 0, 0, 0)
	next
end event

// ========================
// Editor Events
// ========================

event RSDKDraw
	DrawSprite(0)
end event

event RSDKLoad
	LoadSpriteSheet("Players/Sonic1.gif")
	SpriteFrame(-16, -19, 27, 39, 1, 1)
	
	// used in-game, but shouldn't be set from the editor
	SetVariableAlias(ALIAS_VAR_PROPVAL, "unused")
end event