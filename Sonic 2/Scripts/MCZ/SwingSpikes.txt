// ----------------------------------
// RSDK Project: Sonic 2
// Script Description: Swing Spikes Object
// Script Author: Christian Whitehead/Simon Thomley
// Unpacked by Rubberduckycooly's script unpacker
// ----------------------------------

// Aliases
private alias object.propertyValue : object.length

private alias object.value0 : object.timer
private alias object.value1 : object.platform.x
private alias object.value2 : object.platform.y
private alias object.value3 : object.collisionOffset.x
private alias object.value4 : object.collisionOffset.y
private alias object.value5 : object.moveDir
private alias object.value6 : object.swingAngle

// TODO: another case of bad naming
// like, "embark" ??? what's that supposed to mean??
private alias 0 : STATE_AWAITPLAYER
private alias 1 : STATE_EMBARKPAUSE
private alias 2 : STATE_EMBARK
private alias 3 : STATE_RETURNPAUSE
private alias 4 : STATE_RETURN

// Function declarations
reserve function SwingSpikes_DebugDraw
reserve function SwingSpikes_DebugSpawn


function SwingSpikes_DebugDraw
	DrawSprite(0)
end function


function SwingSpikes_DebugSpawn
	CreateTempObject(TypeName[Swing Spikes], 8, object.xpos, object.ypos)
	object[tempObjectPos].moveDir = object.direction
	if object[tempObjectPos].moveDir == FACING_RIGHT
		// Rotating clockwise
		object[tempObjectPos].swingAngle = 0x8000
	else
		// Rotating counter-clockwise
		object[tempObjectPos].swingAngle = 0x0000
	end if
end function


event ObjectMain
	switch object.state
	case STATE_AWAITPLAYER
		foreach (GROUP_PLAYERS, currentPlayer, ACTIVE_ENTITIES)
			BoxCollisionTest(C_TOUCH, object.entityPos, -30, 0, 30, 128, currentPlayer, HITBOX_AUTO, HITBOX_AUTO, HITBOX_AUTO, HITBOX_AUTO)
			if checkResult == true
				object.state = STATE_EMBARKPAUSE

				if object.priority != PRIORITY_XBOUNDS_DESTROY
					object.priority = PRIORITY_ACTIVE
				end if
			end if
		next
		break

	case STATE_EMBARKPAUSE
		object.timer++
		if object.timer == 60
			object.timer = 0
			object.state++
		end if
		break

	case STATE_EMBARK
		object.speed += 8
		if object.moveDir == FACING_RIGHT
			object.swingAngle -= object.speed
			if object.swingAngle <= 0x4000
				object.speed = 0
				object.swingAngle = 0x4000
				object.state++
			end if
		else
			object.swingAngle += object.speed
			if object.swingAngle >= 0x4000
				object.speed = 0
				object.swingAngle = 0x4000
				object.state++
			end if
		end if
		break

	case STATE_RETURNPAUSE
		object.timer++
		if object.timer == 60
			object.timer = 0
			object.state++
		end if
		break

	case STATE_RETURN
		object.speed += 8
		if object.moveDir == FACING_RIGHT
			object.swingAngle += object.speed

			if object.swingAngle >= 0x8000
				object.speed = 0
				object.swingAngle = 0x8000
				object.state = STATE_EMBARKPAUSE
			end if
		else
			object.swingAngle -= object.speed

			if object.swingAngle <= 0
				object.speed = 0
				object.swingAngle = 0x0000
				object.state = STATE_EMBARKPAUSE
			end if
		end if
		break

	end switch

	// Backup object position
	temp2 = object.xpos
	temp3 = object.ypos

	// Get the "actual" angle for the upcoming trigonometry calculations
	object.angle = object.swingAngle
	object.angle >>= 7

	temp1 = object.length
	temp1++
	temp1 <<= 4
	temp1 -= 8
	object.xpos = object.platform.x
	object.ypos = object.platform.y

	// Calculate pplatform X Pos
	Cos(object.collisionOffset.x, object.angle)
	object.collisionOffset.x *= temp1
	object.collisionOffset.x <<= 7
	object.collisionOffset.x += temp2
	object.collisionOffset.x &= -0x10000
	object.platform.x = object.collisionOffset.x
	object.collisionOffset.x -= object.xpos

	// And then calculate pplatform Y Pos
	Sin(object.collisionOffset.y, object.angle)
	object.collisionOffset.y *= temp1
	object.collisionOffset.y <<= 7
	object.collisionOffset.y += temp3
	object.collisionOffset.y &= -0x10000
	object.platform.y = object.collisionOffset.y
	object.collisionOffset.y -= object.ypos

	foreach (GROUP_PLAYERS, currentPlayer, ACTIVE_ENTITIES)
		BoxCollisionTest(C_BOX2, object.entityPos, -30, -8, 30, 8, currentPlayer, HITBOX_AUTO, HITBOX_AUTO, HITBOX_AUTO, HITBOX_AUTO)
		switch checkResult
		case COL_TOP
			object[currentPlayer].xpos += object.collisionOffset.x
			object[currentPlayer].ypos += object.collisionOffset.y
			break

		case COL_LEFT
			CallFunction(PlayerObject_Hit)
			break

		case COL_RIGHT
			CallFunction(PlayerObject_Hit)
			break

		end switch
	next

	// Restore the object's position
	object.xpos = temp2
	object.ypos = temp3

	if object.outOfBounds == true
		if object.priority != PRIORITY_XBOUNDS_DESTROY
			object.priority = PRIORITY_ACTIVE_BOUNDS

			if object.moveDir == FACING_RIGHT
				object.swingAngle = 0x8000
			else
				object.swingAngle = 0x0000
			end if
		end if
	end if
end event


event ObjectDraw
	// Draw all the chains first
	temp0 = 0
	temp1 = 16
	while temp0 < object.length
		Cos(temp2, object.angle)
		temp2 *= temp1
		temp2 <<= 7
		temp2 += object.xpos
		Sin(temp3, object.angle)
		temp3 *= temp1
		temp3 <<= 7
		temp3 += object.ypos
		DrawSpriteXY(1, temp2, temp3)
		temp0++
		temp1 += 16
	loop
	temp1 -= 8

	// Calculate where to draw the platform
	Cos(object.platform.x, object.angle)
	object.platform.x *= temp1
	object.platform.x <<= 7
	object.platform.x += object.xpos
	object.platform.x &= -0x10000

	Sin(object.platform.y, object.angle)
	object.platform.y *= temp1
	object.platform.y <<= 7
	object.platform.y += object.ypos
	object.platform.y &= -0x10000

	// Rock base
	DrawSprite(0)

	// Platform
	DrawSpriteXY(2, object.platform.x, object.platform.y)
end event


event ObjectStartup
	LoadSpriteSheet("MCZ/Objects.gif")

	SpriteFrame(-12, -12, 23, 33, 152, 131) // 0 - Rock frame
	SpriteFrame(-8, -8, 16, 16, 135, 148)   // 1 - Chain frame
	SpriteFrame(-31, -8, 62, 16, 30, 32)    // 2 - Platform frame

	foreach (TypeName[Swing Spikes], arrayPos0, ALL_ENTITIES)
		if object[arrayPos0].propertyValue > 0
			object[arrayPos0].propertyValue--
		end if

		// Spin direction is the 4th bit in the property value
		object[arrayPos0].moveDir = object[arrayPos0].propertyValue
		object[arrayPos0].moveDir >>= 3
		object[arrayPos0].moveDir &= FACING_LEFT
		if object[arrayPos0].moveDir == FACING_RIGHT
			object[arrayPos0].swingAngle = 0x8000
		else
			object[arrayPos0].swingAngle = 0x0000
		end if

		// First three bits in property value are chain length
		object[arrayPos0].propertyValue &= 7
		object[arrayPos0].propertyValue++
	next

	SetTableValue(TypeName[Swing Spikes], DebugMode_ObjCount, DebugMode_TypesTable)
	SetTableValue(SwingSpikes_DebugDraw, DebugMode_ObjCount, DebugMode_DrawTable)
	SetTableValue(SwingSpikes_DebugSpawn, DebugMode_ObjCount, DebugMode_SpawnTable)
	DebugMode_ObjCount++
end event

event RSDKDraw
	temp7 = object.length
	temp7 &= 7
	temp7++
	temp0 = 0
	temp1 = 16
	while temp0 < temp7
		Cos(temp2, object.angle)
		temp2 *= temp1
		temp2 <<= 7
		temp2 += object.xpos
		Sin(temp3, object.angle)
		temp3 *= temp1
		temp3 <<= 7
		temp3 += object.ypos
		DrawSpriteXY(1, temp2, temp3)
		temp0++
		temp1 += 16
	loop
	temp1 -= 8
	Cos(object.platform.x, object.angle)
	object.platform.x *= temp1
	object.platform.x <<= 7
	object.platform.x += object.xpos
	object.platform.x &= -0x10000
	Sin(object.platform.y, object.angle)
	object.platform.y *= temp1
	object.platform.y <<= 7
	object.platform.y += object.ypos
	object.platform.y &= -0x10000
	DrawSprite(0)
	DrawSpriteXY(2, object.platform.x, object.platform.y)
end event

event RSDKLoad
	LoadSpriteSheet("MCZ/Objects.gif")
	SpriteFrame(-12, -12, 23, 33, 152, 131)
	SpriteFrame(-8, -8, 16, 16, 135, 148)
	SpriteFrame(-31, -8, 62, 16, 30, 32)

	// note for rdc when they come along to do rsdkedit stuff:
	// propertyValue follows format of 0000DXXX, where
	// D - direction the platform should swing to
	// XXX - how many chains there should be, 8 separate options max
	// also object.angle can be set to control the starting pos of the thing
end event
