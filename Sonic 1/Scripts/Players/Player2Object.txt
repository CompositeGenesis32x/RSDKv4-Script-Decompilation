// ----------------------------------
// RSDK Project: Sonic 1
// Script Description: Player 2 Object Object
// Script Author: Christian Whitehead/Simon Thomley
// Unpacked by Rubberduckycooly's script unpacker
// ----------------------------------

// ========================
// Aliases
// ========================
private alias object.value1  : player.timer
private alias object.value3  : player.drownTimer			// Countdown before player moves to next drown "level"
private alias object.value4  : player.drownLevel
private alias object.value7  : player.invincibleTimer
private alias object.value8  : player.blinkTimer
private alias object.value12 : player.tailFrame
private alias object.value13 : player.tailAnim
private alias object.value16 : player.isSidekick			// 0/false is player 1, 1/true if player 2
private alias object.value18 : player.sortedDrawOrder
private alias object.value19 : player.scoreBonus
private alias object.value25 : player.gravityStrength 		// Also used in underwater checks , 0x1000 if underwater, otherwise 0x3800. Not to be confused with player.gravity
private alias object.value26 : player.flightVelocity
private alias object.value30 : player.jumpOffset
private alias object.value31 : player.rollingDeceleration	// Passive rolling deceleration - Without the player holding the opposite direction
private alias object.value32 : player.jumpAbility			// Used to store whatever function this player has for its jump ability
private alias object.value33 : player.actionSpindash		// Used to store whatever function this player has for its spindash ability
private alias object.value34 : player.collisionDisabled
private alias object.value40 : player.hitboxLeft
private alias object.value38 : player.hitboxTop
private alias object.value41 : player.hitboxRight
private alias object.value39 : player.hitboxBottom
private alias object.value42 : player.prevGravity
private alias object.value43 : player.jumpInTimer
private alias object.value44 : player.stateInputP2
private alias object.value45 : player.autoJumpTimer
private alias object.value46 : player.targetLeaderPos.x
private alias object.value47 : player.targetLeaderPos.y

// ========================
// Function Declarations
// ========================
reserve function Player2_GetDelayedInput
reserve function Player2_Input_GamepadAssist
reserve function Player2_Input_AI_Follow
reserve function Player2_Input_AI_SpindashPt1
reserve function Player2_Input_AI_SpindashPt2
reserve function Player2_State_FlyToPlayer
reserve function Player2_HandleSidekickRespawn
reserve function Player_ProcessUpdateP2
reserve function Player2_Input_None
reserve function Player2_Action_DblJumpTailsAI

// ========================
// Static Values
// ========================
public value Player2_stateUp 			= 0
public value Player2_stateDown 			= 0
public value Player2_stateLeft 			= 0
public value Player2_stateRight 		= 0
public value Player2_stateJumpPress 	= 0
public value Player2_stateJumpHold 		= 0
public value Player2_nextLeaderPosID 	= 0
public value Player2_lastLeaderPosID 	= 0

// ========================
// Tables
// ========================
public table Player2_leaderPosBufferX[16]
public table Player2_leaderPosBufferY[16]


public function Player2_Input_None
	temp0 = 0
end function


public function Player2_Action_DblJumpTailsAI
	CheckNotEqual(player.stateInputP2, Player2_Input_None)
	temp0 = checkResult
	CheckNotEqual(object.up, true)
	temp0 &= checkResult
	if temp0 == false
		CallFunction(Player_Action_DblJumpTails)
	end if
end function


public function Player2_GetDelayedInput
	if object.controlMode > -1
		Player2_stateUp <<= 1
		Player2_stateUp |= object[0].up
		Player2_stateUp &= 0xFFFF
		Player2_stateDown <<= 1
		Player2_stateDown |= object[0].down
		Player2_stateDown &= 0xFFFF
		Player2_stateLeft <<= 1
		Player2_stateLeft |= object[0].left
		Player2_stateLeft &= 0xFFFF
		Player2_stateRight <<= 1
		Player2_stateRight |= object[0].right
		Player2_stateRight &= 0xFFFF
		Player2_stateJumpPress <<= 1
		Player2_stateJumpPress |= object[0].jumpPress
		Player2_stateJumpPress &= 0xFFFF
		Player2_stateJumpHold <<= 1
		Player2_stateJumpHold |= object[0].jumpHold
		Player2_stateJumpHold &= 0xFFFF

		if object[0].state == Player_State_Carried
			Player2_stateDown <<= 15
			Player2_stateLeft <<= 15
			Player2_stateRight <<= 15
			Player2_stateJumpPress <<= 15
			Player2_stateJumpHold <<= 15
		end if

		temp0 = Player2_stateUp
		temp0 >>= 15
		object.up = temp0

		temp0 = Player2_stateDown
		temp0 >>= 15
		object.down = temp0

		temp0 = Player2_stateLeft
		temp0 >>= 15
		object.left = temp0

		temp0 = Player2_stateRight
		temp0 >>= 15
		object.right = temp0

		temp0 = Player2_stateJumpPress
		temp0 >>= 15
		object.jumpPress = temp0

		temp0 = Player2_stateJumpHold
		temp0 >>= 15
		object.jumpHold = temp0
	else
		Player2_stateUp = 0
		Player2_stateDown = 0
		Player2_stateLeft = 0
		Player2_stateRight = 0
		Player2_stateJumpPress = 0
		Player2_stateJumpHold = 0
	end if

	if object[0].state != Player_State_Death
		if object[0].type != TypeName[Death Event]
			SetTableValue(object[0].xpos, Player2_lastLeaderPosID, Player2_leaderPosBufferX)
			SetTableValue(object[0].ypos, Player2_lastLeaderPosID, Player2_leaderPosBufferY)
			Player2_lastLeaderPosID++
			Player2_lastLeaderPosID &= 15
			Player2_nextLeaderPosID++
			Player2_nextLeaderPosID &= 15
			CheckEqual(object[0].gravity, 1)
			temp0 = checkResult
			CheckEqual(player[0].prevGravity, 0)
			temp0 &= checkResult
			if temp0 == 0
				GetTableValue(player.targetLeaderPos.x, Player2_nextLeaderPosID, Player2_leaderPosBufferX)
				GetTableValue(player.targetLeaderPos.y, Player2_nextLeaderPosID, Player2_leaderPosBufferY)
			else
				player.targetLeaderPos.x = object[0].xpos
				player.targetLeaderPos.y = object[0].ypos
			end if
		else
			temp0 = Player2_lastLeaderPosID
			temp0--
			if temp0 < 0
				temp0 += 16
			end if

			GetTableValue(player.targetLeaderPos.x, temp0, Player2_leaderPosBufferX)
			GetTableValue(player.targetLeaderPos.y, temp0, Player2_leaderPosBufferY)
		end if
	else
		temp0 = Player2_lastLeaderPosID
		temp0--
		if temp0 < 0
			temp0 += 16
		end if

		GetTableValue(player.targetLeaderPos.x, temp0, Player2_leaderPosBufferX)
		GetTableValue(player.targetLeaderPos.y, temp0, Player2_leaderPosBufferY)
	end if
end function


public function Player2_Input_GamepadAssist
#platform: USE_ORIGINS
	IsInputSlotAssigned(2)
	if checkResult == false
		player.stateInputP2 = Player2_Input_AI_Follow
		AssignInputSlotToDevice(2, -1)
		return
	end if
	
	ProcessObjectControl()
	
	temp0 = object.up
	temp0 |= object.down
	temp0 |= object.left
	temp0 |= object.right
	temp0 |= object.jumpHold
	if temp0 == false
		player.autoJumpTimer++
		if player.autoJumpTimer >= 600
			player.stateInputP2 = Player2_Input_AI_Follow
			AssignInputSlotToDevice(2, -1)
		end if
	else
		player.autoJumpTimer = 0
	end if
#endplatform
end function


public function Player2_Input_AI_Follow
	CallFunction(Player2_GetDelayedInput)
	if object[0].type == TypeName[Player Object]
		temp0 = object.angle
		temp0 += 16
		temp0 &= 0xE0
		if temp0 == 0
			if object.left == true
				temp0 = object[0].xpos
				temp0 -= 0x80000
				if object.xpos < temp0
					if object.xvel <= 0
						object.left = false
					end if
				end if
			end if

			if object.right == true
				temp0 = object[0].xpos
				temp0 += 0x80000
				if object.xpos > temp0
					if object.yvel <= 0
						object.right = false
					end if
				end if
			end if
		end if

		if object[0].state != Player_State_Carried
			temp0 = player.targetLeaderPos.x
			temp1 = object[0].gravity
			temp1 |= player[0].prevGravity
			if temp1 == false
				if object[0].speed < 0x20000
					if object[0].speed > -0x20000
						if object[0].direction == 0
							temp0 -= 0x200000
						else
							temp0 += 0x200000
						end if
					end if
				end if
			end if

			temp0 -= object.xpos
			if temp0 != 0
				if temp0 < 0
					if temp0 <= -0x300000
						object.right = false
						object.left = true
					end if

					if object.speed != 0
						if object.direction == 1
							Cos256(temp1, object.angle)
							temp1 *= 0xC0
							object.xpos -= temp1
						end if
					end if
				else
					if temp0 >= 0x300000
						object.left = false
						object.right = true
					end if

					if object.speed != 0
						if object.direction == 0
							Cos256(temp1, object.angle)
							temp1 *= 0xC0
							object.xpos += temp1
						end if
					end if
				end if
			end if

			if object.animation == ANI_PUSHING
				player.autoJumpTimer++
				if object[0].direction == object.direction
					if object[0].animation == ANI_PUSHING
						player.autoJumpTimer = 0
					end if
				end if

				if player.autoJumpTimer >= 30
					if object.gravity == 0
						CallFunction(Player_Action_Jump)
					end if
					player.timer = 0
					player.autoJumpTimer = 0
				end if
			else
				temp0 = object.ypos
				temp0 -= player.targetLeaderPos.y
				if temp0 > 0x200000
					player.autoJumpTimer++
					if player.autoJumpTimer >= 64
						if object.gravity == 0
							CallFunction(Player_Action_Jump)
						end if
						player.timer = 0
						player.autoJumpTimer = 0
					end if
				else
					player.autoJumpTimer = 0
				end if
			end if

			if object.controlLock > 0
				if object.speed < 0x8000
					if object.speed > -0x8000
						player.stateInputP2 = Player2_Input_AI_SpindashPt1
					end if
				end if
			end if
		end if
	end if
	
#platform: USE_ORIGINS
	// Look for input from controller 2
	temp0 = keyDown[2].up
	temp0 |= keyDown[2].down
	temp0 |= keyDown[2].left
	temp0 |= keyDown[2].right
	temp0 |= keyDown[2].buttonA
	temp0 |= keyDown[2].buttonB
	temp0 |= keyDown[2].buttonC
	
	if temp0 == true
		// Enable P2 controls
		player.autoJumpTimer = 0
		player.stateInputP2 = Player2_Input_GamepadAssist
	end if
#endplatform
end function


public function Player2_Input_AI_SpindashPt1
	object.up = false
	object.down = false
	object.left = false
	object.right = false
	object.jumpPress = false
	object.jumpHold = false
	if object.controlLock == 0
		if object.gravity == 0
			if object.speed < 0x4000
				if object.speed > -0x4000
					player.stateInputP2 = Player2_Input_AI_SpindashPt2
					player.autoJumpTimer = 1
					if object.animation != ANI_SPINDASH
						if object.xpos < player.targetLeaderPos.x
							object.direction = FACING_RIGHT
						else
							object.direction = FACING_LEFT
						end if

						object.down = true
					end if
				end if
			end if
		end if
	end if
end function


public function Player2_Input_AI_SpindashPt2
	if player.autoJumpTimer < 64
		object.down = true
		temp0 = player.autoJumpTimer
		temp0 &= 15
		if temp0 == 0
			object.jumpPress = true
		else
			object.jumpPress = false
		end if
		player.autoJumpTimer++
	else
		player.autoJumpTimer = 0
		object.down = false
		object.jumpPress = false
		player.stateInputP2 = Player2_Input_AI_Follow
	end if
end function


public function Player2_State_FlyToPlayer
	CallFunction(Player2_GetDelayedInput)
	if player.gravityStrength == 0x3800
		object.animation = ANI_FLYING
	else
		object.animation = ANI_SWIMMING
	end if

	temp0 = player.targetLeaderPos.x
	temp0 -= object.xpos
	temp1 = temp0
	temp0 >>= 4

	if object.xpos < player.targetLeaderPos.x
		object.direction = FACING_RIGHT
		if temp0 > 0xC0000
			temp0 = 0xC0000
		end if

		if object[0].xvel > 0
			temp0 += object[0].xvel
		end if

		temp0 += 0x10000
		if temp0 > temp1
			temp0 = temp1
			temp1 = 0
		end if
	else
		object.direction = FACING_LEFT
		if temp0 < -0xC0000
			temp0 = -0xC0000
		end if

		if object[0].xvel < 0
			temp0 += object[0].xvel
		end if

		temp0 -= 0x10000
		if temp0 < temp1
			temp0 = temp1
			temp1 = 0
		end if
	end if
	object.xpos += temp0

	if object.ypos < player.targetLeaderPos.y
		object.ypos += 0x10000
	end if
	if object.ypos > player.targetLeaderPos.y
		object.ypos -= 0x10000
	end if

	if object[0].type != TypeName[Death Event]
		if object[0].state != Player_State_Death
			if object[0].state != Player_State_Drown
				if object[0].state != Player_State_TubeRoll
					if temp1 == 0
						temp0 = player.targetLeaderPos.y
						temp0 -= object.ypos
						if temp0 < 0
							FlipSign(temp0)
						end if

						if temp0 < 0x20000
							object.state = Player_State_Air
							object.animation = ANI_JUMPING
							object.gravity = GRAVITY_AIR
							object.tileCollisions = true
							object.interaction = true
							object.controlMode = CONTROLMODE_P2
							object.controlLock = 0
							object.angle = 0
							player.stateInputP2 = Player2_Input_AI_Follow
							object.collisionPlane = object[0].collisionPlane
							Player2_stateUp = 0
							Player2_stateDown = 0
							Player2_stateLeft = 0
							Player2_stateRight = 0
							Player2_stateJumpPress = 0
							Player2_stateJumpHold = 0
						end if
					end if
				end if
			end if
		end if
	end if
end function


public function Player2_HandleSidekickRespawn
	if object[0].type == TypeName[Player Object]
		if object.outOfBounds == true
			player.jumpInTimer++
		else
			player.jumpInTimer = 0
		end if

		if player.jumpInTimer >= 240
			player.jumpInTimer = 0
			object.state = Player2_State_FlyToPlayer
			object.xpos = object[0].xpos
			object.ypos = screen.yoffset
			object.ypos -= 128
			object.ypos <<= 16
			object.xvel = 0
			object.yvel = 0
			object.speed = 0
			object.tileCollisions = false
			object.interaction = false
			object.controlMode = CONTROLMODE_P2
			player.sortedDrawOrder = 4
			player.drownTimer = 0
			player.drownLevel = 0
		end if
		
		CheckEqual(object[0].state, Player_State_Death)
		temp0 = checkResult
		CheckEqual(object[0].type, TypeName[Death Event])
		temp0 |= checkResult
		CheckNotEqual(object.state, Player_State_Hurt)
		temp0 &= checkResult
		CheckNotEqual(object.state, Player_State_Death)
		temp0 &= checkResult
		if temp0 == true
			player.jumpInTimer = 0
			object.state = Player2_State_FlyToPlayer
			object.xvel = 0
			object.yvel = 0
			object.speed = 0
			object.tileCollisions = false
			object.interaction = false
		end if
	end if
end function


public function Player_ProcessUpdateP2
	if object.state == Player_State_Death
		player.stateInputP2 = Player2_Input_None
	end if
	
	if object.state == Player_State_Drown
		player.stateInputP2 = Player2_Input_None
	end if

	CallFunction(player.stateInputP2)

	if object.state != Player_State_Hurt
		if player.blinkTimer > 0
			player.blinkTimer--
			GetBit(temp0, player.blinkTimer, 2)
			if temp0 == true
				object.visible = false
			else
				object.visible = true
			end if
		end if
	end if

	if player.invincibleTimer > 0
		if object.state != Player_State_Hurt
			if player.invincibleTimer > 2000
				player.invincibleTimer = 120
				player.blinkTimer = 3
			end if
		end if

		player.invincibleTimer--
		if player.invincibleTimer == 0
			player.blinkTimer = 0
			object.visible = true
		end if
	end if

	if object.state != Player_State_LookUp
		if object.state != Player_State_Crouch
			if object.lookPosY > 0
				object.lookPosY -= 2
			end if

			if object.lookPosY < 0
				object.lookPosY += 2
			end if
		end if
	end if

	if object.state != Player_State_Fly
		if player.flightVelocity != 0
			StopSfx(SfxName[Flying])
			StopSfx(SfxName[Tired])
			player.flightVelocity = 0
		end if
	end if
end function


// ========================
// Events
// ========================

event ObjectUpdate
	CallFunction(Player_ProcessUpdateP2)
	CallFunction(object.state)
	ProcessAnimation()
	CallFunction(TailsObject_ProcessTailSprite)

	if player.collisionDisabled == false
		temp0 = player.prevGravity
		player.prevGravity = object.gravity
		ProcessObjectMovement()
		player.prevGravity ^= 1
		CheckEqual(object.gravity, 0)
		player.prevGravity |= checkResult
		player.prevGravity ^= 1
		if temp0 == 1
			if player.prevGravity == 0
				player.scoreBonus = 0
				if object.animation == ANI_JUMPING
					if object.down == false
						if object.state != Player_State_Roll
							if object.state != Player_State_TubeRoll
								object.animation = ANI_WALKING
								object.iypos += player.jumpOffset
							end if
						end if
					end if
				end if
			end if
		end if
	else
		player.collisionDisabled = false
	end if

	CallFunction(Player2_HandleSidekickRespawn)
end event


event ObjectDraw
	if object.animation != object.prevAnimation
		object.prevAnimation = object.animation
		object.frame = 0
		object.animationTimer = 0
		object.animationSpeed = 0
	end if
	
	if player.tailAnim != object.animation
		if object.animation > 4
			player.tailFrame = 0
		end if

		if player.tailAnim > 4
			player.tailFrame = 0
		end if

		player.tailAnim = object.animation
	end if
	
	// Draw the Tails part of Tails
	switch player.tailAnim
	case 0 // ANI_STOPPED
		if object.frame == 0
			temp0 = player.tailFrame
			temp0 >>= 3
			if object.visible == true
				DrawSpriteFX(temp0, FX_FLIP, object.xpos, object.ypos)
			end if
		end if
		break
		
	case 1 // ANI_WAITING
	case 3 // ANI_LOOKINGUP
	case 4 // ANI_LOOKINGDOWN
	case 37 // ANI_CONTINUE_UP
		temp0 = player.tailFrame
		temp0 >>= 3
		if object.visible == true
			DrawSpriteFX(temp0, FX_FLIP, object.xpos, object.ypos)
		end if
		break
		
	case 7 // ANI_SKIDDING
	case 8 // ANI_SPINDASH
		temp0 = player.tailFrame
		temp0 >>= 2
		temp0 += 11
		if object.visible == true
			DrawSpriteFX(temp0, FX_FLIP, object.xpos, object.ypos)
		end if
		break
		
	case 10 // ANI_JUMPING
	case 43 // Unknown, this was probably "SSRoll" before it got moved to its own ani file
		temp0 = player.tailFrame
		temp0 >>= 2
		CheckEqual(object.xvel, 0)
		temp1 = checkResult
		CheckEqual(object.yvel, 0)
		temp1 &= checkResult
		temp2 = object.rotation
		if temp1 == 0
			ATan2(object.rotation, object.xvel, object.yvel)
			object.rotation += 16
			object.rotation &= 255
			object.rotation >>= 5
			switch object.rotation
			case 0
			case 8
				temp0 += 5
				object.rotation = 0x00
				break

			case 1
				temp0 += 8
				if object.direction == 0
					object.rotation = 0x40
				else
					object.rotation = 0x00
				end if
				break

			case 2
				temp0 += 5
				object.rotation = 0x40
				break

			case 3
				temp0 += 8
				if object.direction == 0
					object.rotation = 0x80
				else
					object.rotation = 0x40
				end if
				break

			case 4
				temp0 += 5
				object.rotation = 0x80
				break

			case 5
				temp0 += 8
				if object.direction == 0
					object.rotation = 0xC0
				else
					object.rotation = 0x80
				end if
				break

			case 6
				temp0 += 5
				object.rotation = 0xC0
				break

			case 7
				temp0 += 8
				if object.direction == 0
					object.rotation = 0x00
				else
					object.rotation = 0xC0
				end if
				break
			end switch

			if object.direction == 1
				object.rotation += 128
			end if
		else
			temp0 += 5
			object.rotation = 0
		end if

		object.rotation <<= 1
		if object.visible == true
			DrawSpriteFX(temp0, FX_ROTATE, object.xpos, object.ypos)
		end if
		object.rotation = temp2
		break
		
	case 17 // ANI_PUSHING
		temp0 = player.tailFrame
		temp0 /= 10
		temp0 += 11
		if object.visible == true
			DrawSpriteFX(temp0, FX_FLIP, object.xpos, object.ypos)
		end if
		break
	end switch
	
	// Draw Tails himself
	// (Separate tails are drawn in the process above)
	DrawObjectAnimation()
end event


event ObjectStartup
	Player2_nextLeaderPosID 	= 1
	Player2_lastLeaderPosID 	= 0
	Player2_stateUp 			= 0
	Player2_stateDown 		= 0
	Player2_stateLeft 		= 0
	Player2_stateRight 		= 0
	Player2_stateJumpPress 	= 0
	Player2_stateJumpHold 	= 0

	if stage.player2Enabled == true
		ResetObjectEntity(1, TypeName[Player 2 Object], 1, object[0].xpos, object[0].ypos)
		object[1].xpos -= 0x100000
		LoadSpriteSheet("Players/Tails1.gif")
		LoadAnimation("Tails.ani")
		SpriteFrame(-22, -8, 16, 24, 82, 199)
		SpriteFrame(-26, -8, 20, 24, 99, 199)
		SpriteFrame(-26, -8, 20, 24, 120, 199)
		SpriteFrame(-26, -8, 20, 24, 141, 199)
		SpriteFrame(-26, -8, 20, 24, 162, 199)
		SpriteFrame(-35, -8, 24, 16, 231, 166)
		SpriteFrame(-35, -8, 24, 16, 231, 183)
		SpriteFrame(-35, -8, 24, 16, 231, 200)
		SpriteFrame(-25, 9, 20, 16, 235, 217)
		SpriteFrame(-25, 9, 18, 16, 237, 234)
		SpriteFrame(-25, 9, 20, 16, 216, 234)
		SpriteFrame(-30, -6, 24, 16, 231, 166)
		SpriteFrame(-30, -6, 24, 16, 231, 183)
		SpriteFrame(-30, -6, 24, 16, 231, 200)
		object[1].groupID = GROUP_PLAYERS
		object[1].propertyValue = 1
		object[1].state = Player_State_Air
		object[1].priority = PRIORITY_ACTIVE
#platform: USE_STANDALONE
		object[1].controlMode = CONTROLMODE_P1
#endplatform
#platform: USE_ORIGINS
		object[1].controlMode = CONTROLMODE_P2
#endplatform
		object[1].drawOrder = -1
		player[1].sortedDrawOrder = 4
		currentPlayer = 1
		CallFunction(Player_UpdatePhysicsState)
		player[1].rollingDeceleration = 0x2000
		player[1].jumpOffset = -1
		player[1].isSidekick = true
		player[1].jumpAbility = Player2_Action_DblJumpTailsAI
		if options.spindash == true
			player[1].actionSpindash = Player_Action_Spindash
		else
			player[1].actionSpindash = Player_Action_Jump
		end if

		CheckCurrentStageFolder("Continue")
		if checkResult == true
			player[1].stateInputP2 = Player2_Input_None
		else
			player[1].stateInputP2 = Player2_Input_AI_Follow
		end if

		temp0 = 0
		while temp0 < 16
			SetTableValue(object[0].xpos, temp0, Player2_leaderPosBufferX)
			SetTableValue(object[0].ypos, temp0, Player2_leaderPosBufferY)
			temp0++
		loop
		
		// Set player hitboxes
		player[1].hitboxLeft 	= C_BOX
		player[1].hitboxRight 	= C_BOX
		player[1].hitboxTop 	= C_BOX
		player[1].hitboxBottom 	= C_BOX
		
#platform: USE_ORIGINS
		AssignInputSlotToDevice(2, -1)
#endplatform
	end if
end event


event RSDKDraw
	DrawSprite(0)
end event


event RSDKLoad
	LoadSpriteSheet("Global/Display.gif")
	SpriteFrame(-16, -16, 32, 32, 1, 143)
	
	SetVariableAlias(ALIAS_VAR_PROPVAL, "unused")
end event
